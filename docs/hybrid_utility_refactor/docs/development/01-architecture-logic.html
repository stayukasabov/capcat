---
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Development Architecture & Logic</title>
    <link rel="stylesheet" href="../../css/design-system.css">
    <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
    <!-- Header -->
    {% include header.html %}


    <div class="doc-container">
        <div class="container">
            <div class="doc-content">

<div class="nav-breadcrumb"><a href="../index.html">Documentation Home</a> / development</div>
<h1>Development Architecture &amp; Logic</h1>

<h2>Overview</h2>

<p>Capcat implements a hybrid modular architecture combining config-driven simplicity with custom code flexibility. This document explains the technical architecture, design patterns, and implementation logic for junior developers.</p>



<h2>System Architecture</h2>

<h3>High-Level Architecture</h3>

<div class="ascii-art">┌────────────────────────────────────────────────────────────────┐
│                        USER INTERFACES                         │
├────────────────────────────────────────────────────────────────┤
│  CLI Interface (cli.py)         Interactive Mode (interactive.py)│
│  - Argument parsing             - Menu-driven workflow         │
│  - Command routing              - User-friendly prompts        │
│  - Input validation             - Error recovery              │
└───────────────────┬────────────────────────────────────────────┘
                    │
                    ▼
┌────────────────────────────────────────────────────────────────┐
│                     CORE ORCHESTRATION                         │
├────────────────────────────────────────────────────────────────┤
│  Main Application (capcat.py)                                  │
│  - Workflow coordination        - Error handling              │
│  - Resource management          - Graceful shutdown           │
│  - Logging configuration        - Progress tracking           │
└───────────────────┬────────────────────────────────────────────┘
                    │
        ┌───────────┴──────────┬────────────────┐
        ▼                      ▼                ▼
┌──────────────┐    ┌──────────────────┐    ┌──────────────┐
│    SOURCE    │    │     CONTENT      │    │    OUTPUT    │
│   SYSTEM     │    │   PROCESSING     │    │  GENERATION  │
└──────────────┘    └──────────────────┘    └──────────────┘
</div>

<h3>Architectural Layers</h3>

<h3>Layer 1: User Interface</h3>

<h4>Purpose</h4> Accept user input and display results

<h4>Components</h4>
<ol>
<li><code>cli.py</code> - Command-line argument parsing</li>
<li><code>interactive.py</code> - Interactive menu system</li>
<li><code>capcat</code> (bash wrapper) - Entry point automation</li>
</ol>

<h4>Responsibilities</h4>
<ul>
<li>Parse command-line arguments</li>
<li>Validate user input</li>
<li>Route commands to appropriate handlers</li>
<li>Display progress and results</li>
<li>Handle user cancellation (Ctrl+C)</li>
</ul>

<h4>Key Design Decisions</h4>
<ul>
<li>Subcommand architecture (like git, docker)</li>
<li>Questionary library for interactive menus</li>
<li>Bash wrapper handles venv activation automatically</li>
</ul>

<h3>Layer 2: Core Orchestration</h3>

<h4>Purpose</h4> Coordinate all system components

<h4>Components</h4>
<ol>
<li><code>capcat.py</code> - Main application logic</li>
<li><code>core/config.py</code> - Configuration management</li>
<li><code>core/logging_config.py</code> - Logging setup</li>
<li><code>core/shutdown.py</code> - Graceful shutdown handling</li>
</ol>

<h4>Responsibilities</h4>
<ul>
<li>Initialize all subsystems</li>
<li>Coordinate source fetching workflow</li>
<li>Manage shared resources (sessions, connections)</li>
<li>Handle errors and recovery</li>
<li>Clean up on exit</li>
</ul>

<h4>Key Design Patterns</h4>
<ul>
<li>Dependency injection for testability</li>
<li>Context managers for resource cleanup</li>
<li>Singleton pattern for registry/factory</li>
</ul>

<h3>Layer 3: Source System</h3>

<h4>Purpose</h4> Discover, instantiate, and manage news sources

<h4>Components</h4>
<div class="ascii-art">core/source_system/
├── source_registry.py       # Source discovery and registration
├── source_factory.py        # Source instantiation
├── base_source.py           # Abstract base class
├── config_driven_source.py  # YAML-based sources
└── performance_monitor.py   # Metrics and health tracking
</div>

<h4>Architecture</h4> Hybrid system supporting two source types

<h5>Config-Driven Sources (Simple)</h5>

<h4>Purpose</h4> Quick source addition via YAML configuration

<h4>Location</h4> <code>sources/active/config_driven/configs/*.yaml</code>

<h4>Example</h4>
<pre><code># sources/active/config_driven/configs/iq.yaml
display_name: &quot;InfoQ&quot;
base_url: &quot;https://www.infoq.com/news/&quot;
category: tech

# Article discovery
article_selectors:
  - .card__title a
  - .news-headline a

# Content extraction
content_selectors:
  - .article__content
  - article.article

# Image handling
image_selectors:
  - .article__image img
  - figure img

# Optional: Custom settings
max_articles: 50
timeout: 30
</code></pre>

<h4>Processing Flow</h4>
<pre><code>1. Registry discovers YAML files
2. Validator checks schema compliance
3. ConfigDrivenSource loads configuration
4. Source uses BeautifulSoup for extraction
5. Selectors applied in order until match
6. Content converted to Markdown
</code></pre>

<h4>Advantages</h4>
<ul>
<li>No Python coding required</li>
<li>15-30 minute setup time</li>
<li>Easy to maintain and update</li>
<li>Automatic validation</li>
<li>Community contributions simple</li>
</ul>

<h4>Limitations</h4>
<ul>
<li>No JavaScript execution</li>
<li>No complex logic (comments, pagination)</li>
<li>No anti-bot workarounds</li>
<li>Basic selector matching only</li>
</ul>

<h5>Custom Sources (Complex)</h5>

<h4>Purpose</h4> Full control for complex scraping scenarios

<h4>Location</h4> <code>sources/active/custom/&lt;source_name&gt;/source.py</code>

<h4>Example Structure</h4>
<pre><code># sources/active/custom/hn/source.py
from core.source_system.base_source import BaseSource, Article

class HackerNewsSource(BaseSource):
    &quot;&quot;&quot;
    Hacker News source with comment integration
    &quot;&quot;&quot;

    def __init__(self, config, session=None):
        super().__init__(config, session)
        self.api_base = &quot;https://hacker-news.firebaseio.com/v0&quot;

    def get_articles(self, count=30):
        &quot;&quot;&quot;
        Fetch articles from Hacker News API

        Returns:
            List[Article]: Article objects with content
        &quot;&quot;&quot;
        # Fetch top story IDs
        story_ids = self._fetch_top_stories(count)

        # Fetch article details in parallel
        articles = self._fetch_articles_parallel(story_ids)

        # Fetch comments for each article
        for article in articles:
            article.comments = self._fetch_comments(article.id)

        return articles

    def _fetch_top_stories(self, count):
        &quot;&quot;&quot;Fetch top story IDs from API&quot;&quot;&quot;
        response = self.session.get(f&quot;{self.api_base}/topstories.json&quot;)
        return response.json()[:count]

    def _fetch_article_content(self, story_id):
        &quot;&quot;&quot;Fetch individual article&quot;&quot;&quot;
        # Custom logic for HN API
        pass

    def _fetch_comments(self, story_id):
        &quot;&quot;&quot;Recursively fetch comment tree&quot;&quot;&quot;
        # Custom comment parsing
        pass
</code></pre>

<h4>Advantages</h4>
<ul>
<li>Full Python flexibility</li>
<li>API integration possible</li>
<li>Comment system support</li>
<li>Anti-bot protection handling</li>
<li>Complex pagination logic</li>
<li>JavaScript execution (Selenium)</li>
</ul>

<h4>Use Cases</h4>
<ul>
<li>Sites with anti-bot protection</li>
<li>API-based sources</li>
<li>Complex comment systems</li>
<li>Dynamic content loading</li>
<li>Multi-page articles</li>
</ul>

<h3>Layer 4: Content Processing</h3>

<h4>Purpose</h4> Fetch, parse, and convert content

<h4>Components</h4>
<div class="ascii-art">core/
├── article_fetcher.py           # Content fetching and parsing
├── unified_media_processor.py   # Media handling
├── downloader.py                # File downloads
└── html_converter.py            # HTML to Markdown
</div>

<h4>Processing Pipeline</h4>

<div class="ascii-art">1. Article Discovery
   └─&gt; Source.get_articles(count) returns Article objects

2. Content Fetching
   └─&gt; ArticleFetcher.fetch_content(url)
       ├─&gt; HTTP request with retry logic
       ├─&gt; BeautifulSoup parsing
       └─&gt; Content extraction via selectors

3. Media Processing
   └─&gt; UnifiedMediaProcessor.process(content)
       ├─&gt; Identify images, videos, documents
       ├─&gt; Download media files
       ├─&gt; Convert to relative paths
       └─&gt; Embed in Markdown

4. Format Conversion
   └─&gt; HTMLConverter.to_markdown(html)
       ├─&gt; Clean HTML (remove scripts, ads)
       ├─&gt; Convert to Markdown (markdownify)
       ├─&gt; Format code blocks
       └─&gt; Generate final output

5. File Generation
   └─&gt; FileWriter.write(article, output_path)
       ├─&gt; Create folder structure
       ├─&gt; Write article.md
       ├─&gt; Save images/media
       └─&gt; Generate HTML (optional)
</div>

<h4>Key Algorithms</h4>

<h5>Media Embedding Algorithm</h5>
<pre><code>def embed_media(article_content, media_files):
    &quot;&quot;&quot;
    Replace remote media URLs with local file references

    Logic:
    1. Parse HTML/Markdown for media tags
    2. Download each media file
    3. Generate local path (images/01.jpg)
    4. Replace URL with relative path
    5. Update content with new references
    &quot;&quot;&quot;
    media_map = {}

    for idx, media_url in enumerate(extract_media_urls(content)):
        # Download file
        local_path = download_media(media_url, f&quot;images/{idx:02d}&quot;)

        # Map old URL to new path
        media_map[media_url] = local_path

    # Replace all occurrences
    for old_url, new_path in media_map.items():
        content = content.replace(old_url, new_path)

    return content, media_map
</code></pre>

<h5>Content Extraction Algorithm</h5>
<pre><code>def extract_content(html, selectors):
    &quot;&quot;&quot;
    Extract article content using CSS selectors

    Logic:
    1. Try each selector in order
    2. Return first successful match
    3. Fallback to readability algorithm
    4. Clean extracted content
    &quot;&quot;&quot;
    soup = BeautifulSoup(html, &#x27;lxml&#x27;)

    # Try each configured selector
    for selector in selectors:
        content = soup.select_one(selector)
        if content and len(content.get_text()) &gt; 100:
            return clean_content(content)

    # Fallback: Readability algorithm
    return extract_via_readability(html)
</code></pre>

<h3>Layer 5: Output Generation</h3>

<h4>Purpose</h4> Create organized file structures and formats

<h4>Components</h4>
<div class="ascii-art">core/
├── utils.py              # Folder creation and naming
├── formatter.py          # Text formatting
└── htmlgen/
    ├── generator.py      # HTML generation
    └── templates/        # Jinja2 templates
</div>

<h4>Output Structure Logic</h4>

<pre><code>def create_output_structure(article, batch_mode=True):
    &quot;&quot;&quot;
    Generate output folder structure

    Batch mode:
        ../News/news_DD-MM-YYYY/Source_DD-MM-YYYY/NN_Title/

    Single mode:
        ../Capcats/cc_DD-MM-YYYY-Title/
    &quot;&quot;&quot;
    date_str = datetime.now().strftime(&#x27;%d-%m-%Y&#x27;)

    if batch_mode:
        # Batch: organized by date and source
        base_dir = f&quot;../News/news_{date_str}&quot;
        source_dir = f&quot;{article.source}_{date_str}&quot;
        article_dir = f&quot;{article.number:02d}_{slugify(article.title)}&quot;

        path = Path(base_dir) / source_dir / article_dir
    else:
        # Single: direct archiving
        article_name = f&quot;cc_{date_str}-{slugify(article.title)}&quot;
        path = Path(&quot;../Capcats&quot;) / article_name

    # Create structure
    path.mkdir(parents=True, exist_ok=True)
    (path / &quot;images&quot;).mkdir(exist_ok=True)
    (path / &quot;files&quot;).mkdir(exist_ok=True)

    return path
</code></pre>

<h4>Naming Convention Logic</h4>
<pre><code>def slugify(title, max_length=60):
    &quot;&quot;&quot;
    Convert article title to filesystem-safe name

    Logic:
    1. Convert to lowercase
    2. Replace spaces with underscores
    3. Remove special characters
    4. Truncate to max_length
    5. Remove trailing underscores
    &quot;&quot;&quot;
    slug = title.lower()
    slug = re.sub(r&#x27;[^a-z0-9\s-]&#x27;, &#x27;&#x27;, slug)
    slug = re.sub(r&#x27;[\s-]+&#x27;, &#x27;_&#x27;, slug)
    slug = slug[:max_length].rstrip(&#x27;_&#x27;)

    return slug
</code></pre>



<h2>Core Design Patterns</h2>

<h3>1. Factory Pattern (Source Creation)</h3>

<h4>Problem</h4> Need to create different source types dynamically

<h4>Solution</h4> SourceFactory centralizes source instantiation

<pre><code>class SourceFactory:
    @staticmethod
    def create_source(config, session=None):
        &quot;&quot;&quot;
        Create appropriate source type based on configuration

        Returns:
            ConfigDrivenSource or CustomSource instance
        &quot;&quot;&quot;
        if config.source_type == &#x27;config_driven&#x27;:
            return ConfigDrivenSource(config, session)
        elif config.source_type == &#x27;custom&#x27;:
            return load_custom_source(config, session)
        else:
            raise ValueError(f&quot;Unknown source type: {config.source_type}&quot;)
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Centralized creation logic</li>
<li>Easy to add new source types</li>
<li>Consistent initialization</li>
<li>Testable in isolation</li>
</ul>

<h3>2. Registry Pattern (Source Discovery)</h3>

<h4>Problem</h4> Need to automatically discover available sources

<h4>Solution</h4> SourceRegistry maintains source inventory

<pre><code>class SourceRegistry:
    def __init__(self):
        self._sources = {}
        self._configs = {}

    def discover_sources(self):
        &quot;&quot;&quot;
        Auto-discover sources from filesystem

        Process:
        1. Scan sources/active/config_driven/configs/*.yaml
        2. Scan sources/active/custom/*/source.py
        3. Validate each source
        4. Register in internal registry
        &quot;&quot;&quot;
        # Discover config-driven sources
        config_dir = Path(&quot;sources/active/config_driven/configs&quot;)
        for yaml_file in config_dir.glob(&quot;*.yaml&quot;):
            config = self._load_config(yaml_file)
            if self._validate_config(config):
                self._register_source(config)

        # Discover custom sources
        custom_dir = Path(&quot;sources/active/custom&quot;)
        for source_dir in custom_dir.iterdir():
            if (source_dir / &quot;source.py&quot;).exists():
                config = self._load_custom_config(source_dir)
                self._register_source(config)

    def get_source(self, source_id, session=None):
        &quot;&quot;&quot;Retrieve source instance by ID&quot;&quot;&quot;
        config = self._configs.get(source_id)
        if not config:
            raise ValueError(f&quot;Source not found: {source_id}&quot;)

        return SourceFactory.create_source(config, session)
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Automatic source discovery</li>
<li>No manual registration needed</li>
<li>Validation at discovery time</li>
<li>Single source of truth</li>
</ul>

<h3>3. Strategy Pattern (Content Extraction)</h3>

<h4>Problem</h4> Different sources need different extraction strategies

<h4>Solution</h4> Pluggable extraction strategies

<pre><code>class ExtractionStrategy:
    def extract_content(self, html):
        raise NotImplementedError

class SelectorStrategy(ExtractionStrategy):
    def __init__(self, selectors):
        self.selectors = selectors

    def extract_content(self, html):
        soup = BeautifulSoup(html, &#x27;lxml&#x27;)
        for selector in self.selectors:
            content = soup.select_one(selector)
            if content:
                return content
        return None

class ReadabilityStrategy(ExtractionStrategy):
    def extract_content(self, html):
        # Use readability algorithm
        return extract_readable_content(html)

class APIStrategy(ExtractionStrategy):
    def extract_content(self, api_response):
        # Parse API JSON response
        return api_response[&#x27;content&#x27;]
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Flexible extraction methods</li>
<li>Easy to add new strategies</li>
<li>Sources choose appropriate strategy</li>
<li>Testable in isolation</li>
</ul>

<h3>4. Session Pooling Pattern (Connection Reuse)</h3>

<h4>Problem</h4> Creating new HTTP connections for each request is slow

<h4>Solution</h4> Shared session pool for all sources

<pre><code>class SessionPool:
    def __init__(self):
        self._session = None

    def get_session(self):
        &quot;&quot;&quot;
        Get or create shared requests.Session

        Benefits:
        - Connection reuse (HTTP keep-alive)
        - Cookie persistence
        - Retry logic configuration
        - Timeout management
        &quot;&quot;&quot;
        if self._session is None:
            self._session = requests.Session()

            # Configure retry logic
            retry = Retry(
                total=3,
                backoff_factor=0.5,
                status_forcelist=[500, 502, 503, 504]
            )
            adapter = HTTPAdapter(max_retries=retry)

            self._session.mount(&#x27;http://&#x27;, adapter)
            self._session.mount(&#x27;https://&#x27;, adapter)

            # Set default headers
            self._session.headers.update({
                &#x27;User-Agent&#x27;: &#x27;Capcat/2.0 (News Archiver)&#x27;
            })

        return self._session

    def close(self):
        &quot;&quot;&quot;Clean up session&quot;&quot;&quot;
        if self._session:
            self._session.close()
            self._session = None
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Faster subsequent requests (connection reuse)</li>
<li>Consistent retry logic</li>
<li>Centralized header management</li>
<li>Resource cleanup on exit</li>
</ul>

<h3>5. Observer Pattern (Progress Tracking)</h3>

<h4>Problem</h4> Need to report progress without tight coupling

<h4>Solution</h4> Progress observers notify UI components

<pre><code>class ProgressTracker:
    def __init__(self):
        self._observers = []

    def attach(self, observer):
        &quot;&quot;&quot;Register progress observer&quot;&quot;&quot;
        self._observers.append(observer)

    def update_progress(self, current, total, message=&quot;&quot;):
        &quot;&quot;&quot;Notify all observers of progress update&quot;&quot;&quot;
        for observer in self._observers:
            observer.on_progress(current, total, message)

class TerminalProgressObserver:
    def on_progress(self, current, total, message):
        &quot;&quot;&quot;Display progress bar in terminal&quot;&quot;&quot;
        percentage = (current / total) * 100
        bar = &quot;=&quot; * int(percentage / 2)
        print(f&quot;\r[{bar:&lt;50}] {percentage:.0f}% {message}&quot;, end=&quot;&quot;)

class LogProgressObserver:
    def on_progress(self, current, total, message):
        &quot;&quot;&quot;Log progress to file&quot;&quot;&quot;
        logger.info(f&quot;Progress: {current}/{total} - {message}&quot;)
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Decoupled progress reporting</li>
<li>Multiple output formats (terminal, log, GUI)</li>
<li>Easy to add new observers</li>
<li>Core logic unaware of UI</li>
</ul>



<h2>Data Flow</h2>

<h3>Complete Article Fetching Flow</h3>

<div class="ascii-art">User Input
    |
    v
[CLI Parser]
    |
    ├─&gt; Parse command (fetch, bundle, single)
    ├─&gt; Validate arguments
    └─&gt; Extract parameters (count, sources, options)
    |
    v
[Source Registry]
    |
    ├─&gt; Resolve source IDs (hn -&gt; HackerNewsSource)
    ├─&gt; Expand bundles (tech -&gt; [gizmodo, futurism, ieee])
    └─&gt; Validate sources exist
    |
    v
[Source Factory]
    |
    ├─&gt; Create source instances
    ├─&gt; Inject shared session
    └─&gt; Configure source parameters
    |
    v
[Parallel Processing]
    |
    ├─&gt; For each source concurrently:
    │   |
    │   └─&gt; [Source.get_articles(count)]
    │       |
    │       ├─&gt; Discover article URLs
    │       ├─&gt; Fetch article content
    │       ├─&gt; Extract text/media
    │       └─&gt; Return Article objects
    |
    v
[Content Processing]
    |
    ├─&gt; For each article:
    │   |
    │   ├─&gt; [ArticleFetcher.fetch_content(url)]
    │   │   ├─&gt; HTTP request with retries
    │   │   ├─&gt; Parse HTML with BeautifulSoup
    │   │   └─&gt; Extract via selectors
    │   |
    │   ├─&gt; [UnifiedMediaProcessor.process(article)]
    │   │   ├─&gt; Identify media URLs
    │   │   ├─&gt; Download files (parallel)
    │   │   ├─&gt; Convert to local paths
    │   │   └─&gt; Embed in content
    │   |
    │   └─&gt; [HTMLConverter.to_markdown(html)]
    │       ├─&gt; Clean HTML
    │       ├─&gt; Convert to Markdown
    │       └─&gt; Format output
    |
    v
[Output Generation]
    |
    ├─&gt; [FileWriter.create_structure()]
    │   ├─&gt; Generate folder paths
    │   └─&gt; Create directories
    |
    ├─&gt; [FileWriter.write_article()]
    │   ├─&gt; Write article.md
    │   ├─&gt; Save metadata
    │   └─&gt; Copy media files
    |
    └─&gt; [HTMLGenerator.generate()] (if --html)
        ├─&gt; Load template
        ├─&gt; Render HTML
        └─&gt; Write html/index.html
    |
    v
[Completion]
    |
    ├─&gt; Display summary
    ├─&gt; Log statistics
    └─&gt; Clean up resources
</div>



<h2>Error Handling Strategy</h2>

<h3>Error Hierarchy</h3>

<div class="ascii-art">CapcatError (Base exception)
├── ConfigurationError
│   ├── InvalidConfigError
│   └── MissingConfigError
├── SourceError
│   ├── SourceNotFoundError
│   ├── SourceUnavailableError
│   └── ArticleFetchError
├── NetworkError
│   ├── ConnectionError
│   ├── TimeoutError
│   └── DNSError
├── ProcessingError
│   ├── ParseError
│   ├── ConversionError
│   └── MediaDownloadError
└── FileSystemError
    ├── PermissionError
    ├── DiskFullError
    └── PathError
</div>

<h3>Error Handling Patterns</h3>

<pre><code>def fetch_with_retry(url, max_retries=3):
    &quot;&quot;&quot;
    Fetch URL with exponential backoff retry

    Logic:
    1. Try request
    2. If fails, wait and retry
    3. Exponential backoff: 1s, 2s, 4s
    4. After max_retries, raise exception
    &quot;&quot;&quot;
    for attempt in range(max_retries):
        try:
            response = session.get(url, timeout=30)
            response.raise_for_status()
            return response

        except requests.Timeout:
            if attempt == max_retries - 1:
                raise TimeoutError(f&quot;Request timeout after {max_retries} attempts&quot;)
            time.sleep(2 ** attempt)  # Exponential backoff

        except requests.ConnectionError:
            if attempt == max_retries - 1:
                raise NetworkError(f&quot;Connection failed after {max_retries} attempts&quot;)
            time.sleep(2 ** attempt)

        except requests.HTTPError as e:
            if e.response.status_code &gt;= 500:
                # Server error, retry
                if attempt == max_retries - 1:
                    raise SourceUnavailableError(f&quot;Server error: {e}&quot;)
                time.sleep(2 ** attempt)
            else:
                # Client error, don&#x27;t retry
                raise ArticleFetchError(f&quot;HTTP {e.response.status_code}: {e}&quot;)
</code></pre>

<h3>Graceful Degradation</h3>

<pre><code>def process_articles(articles):
    &quot;&quot;&quot;
    Process articles with graceful failure handling

    Strategy:
    - Continue processing on individual failures
    - Collect errors for reporting
    - Save successful articles
    - Report summary at end
    &quot;&quot;&quot;
    successful = []
    failed = []

    for article in articles:
        try:
            processed = process_article(article)
            successful.append(processed)

        except MediaDownloadError as e:
            # Save article without media
            logger.warning(f&quot;Media download failed: {e}&quot;)
            article.media_warning = str(e)
            successful.append(article)

        except ProcessingError as e:
            # Skip this article, continue with others
            logger.error(f&quot;Failed to process article: {e}&quot;)
            failed.append((article, e))

        except Exception as e:
            # Unexpected error, log and continue
            logger.exception(f&quot;Unexpected error: {e}&quot;)
            failed.append((article, e))

    # Report summary
    logger.info(f&quot;Processed {len(successful)}/{len(articles)} articles&quot;)
    if failed:
        logger.warning(f&quot;Failed articles: {len(failed)}&quot;)
        for article, error in failed:
            logger.warning(f&quot;  - {article.title}: {error}&quot;)

    return successful, failed
</code></pre>



<h2>Performance Optimizations</h2>

<h3>1. Parallel Article Fetching</h3>

<pre><code>def fetch_articles_parallel(sources, count):
    &quot;&quot;&quot;
    Fetch articles from multiple sources concurrently

    Performance gain: 5x faster than sequential
    &quot;&quot;&quot;
    from concurrent.futures import ThreadPoolExecutor, as_completed

    with ThreadPoolExecutor(max_workers=len(sources)) as executor:
        # Submit all source fetching tasks
        future_to_source = {
            executor.submit(source.get_articles, count): source
            for source in sources
        }

        # Collect results as they complete
        results = {}
        for future in as_completed(future_to_source):
            source = future_to_source[future]
            try:
                articles = future.result(timeout=300)  # 5 min timeout
                results[source.id] = articles
            except Exception as e:
                logger.error(f&quot;Source {source.id} failed: {e}&quot;)
                results[source.id] = []

    return results
</code></pre>

<h3>2. Connection Pooling</h3>

<h4>Benefit</h4> Reuse TCP connections instead of creating new ones

<pre><code># Without pooling
for url in urls:
    response = requests.get(url)  # New connection each time
    # 100-500ms connection overhead per request

# With pooling (via Session)
session = requests.Session()
for url in urls:
    response = session.get(url)  # Reuse existing connection
    # ~10ms overhead after first connection
</code></pre>

<h4>Performance Impact</h4>
<ul>
<li>First request: 500ms (connection + data)</li>
<li>Subsequent requests: 150ms (data only)</li>
<li>70% time reduction for multi-request sources</li>
</ul>

<h3>3. Lazy Loading</h3>

<pre><code>class Article:
    def __init__(self, url, title):
        self.url = url
        self.title = title
        self._content = None  # Lazy loaded
        self._comments = None  # Lazy loaded

    @property
    def content(self):
        &quot;&quot;&quot;Lazy load content only when accessed&quot;&quot;&quot;
        if self._content is None:
            self._content = fetch_content(self.url)
        return self._content

    @property
    def comments(self):
        &quot;&quot;&quot;Lazy load comments only when accessed&quot;&quot;&quot;
        if self._comments is None:
            self._comments = fetch_comments(self.url)
        return self._comments
</code></pre>

<h4>Benefit</h4> Don&#x27;t fetch content not needed (e.g., comments if --no-comments)

<h3>4. Caching</h3>

<pre><code>from functools import lru_cache

@lru_cache(maxsize=1000)
def fetch_source_config(source_id):
    &quot;&quot;&quot;
    Cache source configurations

    Avoids: Re-reading YAML files multiple times
    &quot;&quot;&quot;
    config_path = Path(f&quot;sources/active/config_driven/configs/{source_id}.yaml&quot;)
    with open(config_path) as f:
        return yaml.safe_load(f)
</code></pre>



<h2>Testing Strategy</h2>

<h3>Unit Testing</h3>

<pre><code># Test individual components in isolation

class TestSourceRegistry:
    def test_discover_sources(self):
        registry = SourceRegistry()
        sources = registry.discover_sources()

        assert len(sources) &gt; 0
        assert &#x27;hn&#x27; in sources
        assert &#x27;bbc&#x27; in sources

    def test_get_source(self):
        registry = SourceRegistry()
        registry.discover_sources()

        source = registry.get_source(&#x27;hn&#x27;)

        assert isinstance(source, BaseSource)
        assert source.id == &#x27;hn&#x27;
        assert source.display_name == &#x27;Hacker News&#x27;
</code></pre>

<h3>Integration Testing</h3>

<pre><code># Test component interactions

class TestArticleFetching:
    def test_fetch_and_process_article(self):
        source = HackerNewsSource(config, session)
        articles = source.get_articles(count=5)

        assert len(articles) == 5

        for article in articles:
            # Test content fetching
            assert article.content is not None
            assert len(article.content) &gt; 100

            # Test media processing
            assert article.images is not None

            # Test output generation
            output_path = generate_output(article)
            assert output_path.exists()
            assert (output_path / &quot;article.md&quot;).exists()
</code></pre>

<h3>End-to-End Testing</h3>

<pre><code># Test complete user workflows

def test_bundle_command():
    &quot;&quot;&quot;Test: ./capcat bundle tech --count 10&quot;&quot;&quot;
    result = subprocess.run(
        [&quot;./capcat&quot;, &quot;bundle&quot;, &quot;tech&quot;, &quot;--count&quot;, &quot;10&quot;],
        capture_output=True,
        text=True
    )

    assert result.returncode == 0
    assert &quot;articles saved&quot; in result.stdout

    # Verify output structure
    news_dir = Path(&quot;../News&quot;)
    assert news_dir.exists()

    # Check created folders
    date_str = datetime.now().strftime(&#x27;%d-%m-%Y&#x27;)
    batch_dir = news_dir / f&quot;news_{date_str}&quot;
    assert batch_dir.exists()

    # Count articles
    article_dirs = list(batch_dir.rglob(&quot;*/article.md&quot;))
    assert len(article_dirs) &gt;= 10  # Should have ~30 (10 per source)
</code></pre>



<h2>Configuration Management</h2>

<h3>Configuration Hierarchy</h3>

<pre><code>1. Command-line arguments (highest priority)
2. Environment variables
3. Config file (capcat.yml)
4. Default values (lowest priority)
</code></pre>

<h3>Config File Structure</h3>

<pre><code># capcat.yml

# Default settings
default_count: 30
output_directory: &quot;../News&quot;
media_downloads: false  # images only
html_generation: false

# Network settings
timeout: 30
max_retries: 3
user_agent: &quot;Capcat/2.0&quot;

# Source preferences
preferred_sources:
  - hn
  - bbc
  - nature

# Bundle definitions (custom)
custom_bundles:
  mytech:
    sources: [hn, lb, iq, ieee]
    description: &quot;My tech bundle&quot;

# Logging
log_level: INFO
log_file: &quot;capcat.log&quot;

# Privacy
anonymize_usernames: true
</code></pre>

<h3>Config Loading Logic</h3>

<pre><code>def get_config():
    &quot;&quot;&quot;
    Load configuration from multiple sources

    Priority:
    1. CLI args override everything
    2. Environment variables override file
    3. Config file overrides defaults
    4. Built-in defaults
    &quot;&quot;&quot;
    # Start with defaults
    config = {
        &#x27;default_count&#x27;: 30,
        &#x27;output_directory&#x27;: &#x27;../News&#x27;,
        &#x27;media_downloads&#x27;: False,
        &#x27;html_generation&#x27;: False,
        &#x27;timeout&#x27;: 30,
    }

    # Load from config file if exists
    config_file = Path(&#x27;capcat.yml&#x27;)
    if config_file.exists():
        with open(config_file) as f:
            file_config = yaml.safe_load(f)
            config.update(file_config)

    # Override with environment variables
    if &#x27;CAPCAT_OUTPUT_DIR&#x27; in os.environ:
        config[&#x27;output_directory&#x27;] = os.environ[&#x27;CAPCAT_OUTPUT_DIR&#x27;]

    if &#x27;CAPCAT_DEFAULT_COUNT&#x27; in os.environ:
        config[&#x27;default_count&#x27;] = int(os.environ[&#x27;CAPCAT_DEFAULT_COUNT&#x27;])

    # CLI arguments applied by argparse in cli.py

    return config
</code></pre>



<h2>Security Considerations</h2>

<h3>1. Input Validation</h3>

<pre><code>def validate_count(count):
    &quot;&quot;&quot;Validate article count parameter&quot;&quot;&quot;
    if not isinstance(count, int):
        raise ValidationError(&quot;Count must be integer&quot;)

    if count &lt; 1:
        raise ValidationError(&quot;Count must be positive&quot;)

    if count &gt; 1000:
        raise ValidationError(&quot;Count limited to 1000 (performance)&quot;)

    return count

def validate_url(url):
    &quot;&quot;&quot;Validate single article URL&quot;&quot;&quot;
    parsed = urllib.parse.urlparse(url)

    if not parsed.scheme in [&#x27;http&#x27;, &#x27;https&#x27;]:
        raise ValidationError(&quot;URL must use http or https&quot;)

    if not parsed.netloc:
        raise ValidationError(&quot;Invalid URL format&quot;)

    return url
</code></pre>

<h3>2. Path Sanitization</h3>

<pre><code>def sanitize_path(user_input):
    &quot;&quot;&quot;
    Prevent path traversal attacks

    Blocks: ../../../etc/passwd
    &quot;&quot;&quot;
    # Remove path traversal attempts
    cleaned = user_input.replace(&#x27;..&#x27;, &#x27;&#x27;)

    # Remove absolute paths
    cleaned = cleaned.lstrip(&#x27;/&#x27;)

    # Remove special characters
    cleaned = re.sub(r&#x27;[^\w\s-]&#x27;, &#x27;&#x27;, cleaned)

    return cleaned
</code></pre>

<h3>3. Username Anonymization</h3>

<pre><code>def anonymize_comment(comment_html):
    &quot;&quot;&quot;
    Replace usernames with &#x27;Anonymous&#x27; for privacy

    Preserves: Profile links (for attribution)
    Removes: Identifying usernames in text
    &quot;&quot;&quot;
    soup = BeautifulSoup(comment_html, &#x27;lxml&#x27;)

    # Find username elements
    for username_elem in soup.find_all(class_=&#x27;username&#x27;):
        original_username = username_elem.get_text()
        profile_url = username_elem.find(&#x27;a&#x27;)[&#x27;href&#x27;]

        # Replace with anonymous
        username_elem.string = &#x27;Anonymous&#x27;

        # Preserve profile link (for attribution)
        username_elem[&#x27;data-original-profile&#x27;] = profile_url

    return str(soup)
</code></pre>



<h4>Document Status</h4> Living document
<h4>Last Updated</h4> 2025-01-06
<h4>Target Audience</h4> Junior developers, new team members
<h4>Prerequisites</h4> Python basics, HTTP fundamentals
<h4>Next Steps</h4> Read 02-development-workflow.md


<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
      // Primary colors from design system (Capcat orange palette)
      primaryColor: '#FFD4B7',           // --orange-200
      primaryTextColor: '#201419',       // --ink
      primaryBorderColor: '#F1540E',     // --orange-500 / --accent-primary

      // Line and edge colors
      lineColor: '#58444c',              // --ink-medium

      // Secondary colors
      secondaryColor: '#FFEADB',         // --orange-100
      tertiaryColor: '#f9f8ed',          // --accent-cream-primary

      // Text colors
      textColor: '#201419',              // --ink
      mainBkg: '#FAF8EE',                // --cream

      // Node styling
      nodeBorder: '#F1540E',             // --accent-primary
      clusterBkg: '#faf2e7',             // --accent-cream-light
      clusterBorder: '#D44400',          // --orange-600 / --accent-hover

      // Font
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      fontSize: '16px'
    },
    flowchart: {
      nodeSpacing: 50,
      rankSpacing: 50,
      padding: 15,
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis'
    }
  });

  // Add copy buttons to Mermaid diagrams after rendering
  document.addEventListener('DOMContentLoaded', function() {
    const mermaidDivs = document.querySelectorAll('.mermaid');

    mermaidDivs.forEach(function(mermaidDiv) {
      // Get the original Mermaid source code
      const mermaidSource = mermaidDiv.textContent;

      // Create container wrapper
      const container = document.createElement('div');
      container.className = 'mermaid-container';

      // Create copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'mermaid-copy-btn';
      copyBtn.textContent = 'Copy Mermaid Code';
      copyBtn.setAttribute('title', 'Copy diagram code for Draw.io, Mermaid Live, etc.');

      copyBtn.addEventListener('click', function() {
        navigator.clipboard.writeText(mermaidSource).then(function() {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');

          setTimeout(function() {
            copyBtn.textContent = 'Copy Mermaid Code';
            copyBtn.classList.remove('copied');
          }, 2000);
        });
      });

      // Wrap the mermaid div in container and add button
      mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
      container.appendChild(mermaidDiv);
      container.appendChild(copyBtn);
    });
  });
</script>
    <script src="../../js/main.js"></script>

            
<nav class="chapter-navigation" aria-label="Chapter navigation">
    <div class="next-chapter-content">
        <span class="next-chapter-label">Next Chapter</span>
        <span class="next-chapter-arrow" aria-hidden="true">→</span>
        <a href="02-team-onboarding.html" class="next-chapter-link" rel="next">Team Onboarding</a>
    </div>
</nav>
</div>
        </div>
    </div>

    <!-- Footer -->
    {% include footer.html %}

    <!-- Back to Top Button -->
    <button id="backToTopBtn" title="Go to top">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
        </svg>
    </button>  </body>
