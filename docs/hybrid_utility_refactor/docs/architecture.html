<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture Overview</title>
    <link rel="stylesheet" href="../css/design-system.css">
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <!-- Header -->
    {% include header.html %}


    <div class="doc-container">
        <div class="container">
            <div class="doc-content">

<div class="nav-breadcrumb"><a href="index.html">Documentation Home</a></div>
<h1>Architecture Overview</h1>

<p>Capcat 2.0 implements a hybrid architecture that combines config-driven simplicity with custom implementation flexibility.</p>

<h2>System Architecture</h2>

<div class="ascii-art">┌─────────────────────────────────────────────────────────────┐
│                    Capcat 2.0 Architecture                │
├─────────────────────────────────────────────────────────────┤
│  User Interface Layer                                       │
│  ├── Interactive Mode (catch)                             │
│  │   ├── Main menu (bundle/fetch/single/manage/exit)      │
│  │   └── Source management submenu                         │
│  └── CLI Interface (capcat.py)                            │
│      ├── bundle tech|news|science|aggregators              │
│      ├── fetch source1,source2,source3                     │
│      └── single https://example.com/article                │
├─────────────────────────────────────────────────────────────┤
│  Core Processing Layer                                      │
│  ├── SourceRegistry (Discovery &amp; Management)               │
│  ├── SourceFactory (Instantiation &amp; Pooling)              │
│  ├── PerformanceMonitor (Metrics &amp; Health)                 │
│  └── ValidationEngine (Quality Assurance)                  │
├─────────────────────────────────────────────────────────────┤
│  Hybrid Source Layer                                       │
│  ├── Config-Driven Sources (5 sources)                    │
│  │   └── YAML configurations → ConfigDrivenSource          │
│  └── Custom Sources (6 sources)                            │
│      └── Python implementations → BaseSource               │
├─────────────────────────────────────────────────────────────┤
│  Shared Infrastructure                                      │
│  ├── SessionPool (Network Optimization)                    │
│  ├── ArticleFetcher (Content Processing)                   │
│  ├── TemplateSystem (HTML Generation)                      │
│  │   ├── article-with-comments.html                        │
│  │   ├── article-no-comments.html                          │
│  │   └── comments-with-navigation.html                     │
│  ├── UnifiedMediaProcessor (Image/Media Embedding)         │
│  │   ├── MediaEmbeddingProcessor (Core Engine)             │
│  │   ├── ImageProcessor (Global Image Coordinator)        │
│  │   ├── WebsiteClassifier (Aggregator Protection)        │
│  │   ├── MediaConfigManager (Source Configs)              │
│  │   └── Source-specific media processing configs          │
│  ├── MediaDownloader (Images/Videos/Documents)             │
│  └── Formatter (HTML → Markdown)                           │
└─────────────────────────────────────────────────────────────┘
</div>

<h2>Hybrid Source Types</h2>

<h3>Config-Driven Sources (Simple)</h3>
<h4>Purpose</h4> Simplified development for straightforward news sites
<h4>Count</h4> 5 sources
<h4>Examples</h4> InfoQ, Straits Times, Gizmodo, IEEE, Scientific American

<pre><code># Example: sources/active/config_driven/configs/iq.yaml
display_name: &quot;InfoQ&quot;
base_url: &quot;https://www.infoq.com/news/&quot;
category: tech
article_selectors:
  - .card__title a
  - .news-headline a
content_selectors:
  - .article__content
  - article.article
</code></pre>

<h4>Benefits</h4>
<ul>
<li>No Python coding required</li>
<li>Rapid deployment</li>
<li>Easy maintenance through configuration updates</li>
<li>Automatic validation and testing</li>
</ul>

<h3>Custom Sources (Complex)</h3>
<h4>Purpose</h4> Full flexibility for complex scraping scenarios
<h4>Count</h4> 6 sources
<h4>Examples</h4> Hacker News, BBC, CNN, Nature, Lobsters, LessWrong

<pre><code># Example: sources/active/custom/hn/source.py
class HackerNewsSource(BaseSource):
    def get_articles(self, count=30):
        # Custom logic for Hacker News API integration
        # Comment system handling
        # Anti-bot protection workarounds
        pass
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Full control over scraping logic</li>
<li>Comment system integration</li>
<li>Anti-bot protection handling</li>
<li>Dynamic content loading support</li>
</ul>

<h2>Core Components</h2>

<h3>1. SourceRegistry Pattern</h3>
<h4>Location</h4> <code>core/source_system/source_registry.py</code>
<h4>Purpose</h4> Auto-discovery and management of all sources

<pre><code># Automatic source discovery
registry = get_source_registry()
sources = registry.discover_sources()  # Returns 20 sources

# Source instantiation with session pooling
source = registry.get_source(&#x27;hn&#x27;, session=global_session)
</code></pre>

<h4>Features</h4>
<ul>
<li>Auto-discovery from <code>sources/active/</code></li>
<li>Validation during discovery</li>
<li>Source type management (config vs custom)</li>
<li>Instance caching for performance</li>
</ul>

<h3>2. Factory Pattern Implementation</h3>
<h4>Location</h4> <code>core/source_system/source_factory.py</code>
<h4>Purpose</h4> Unified source creation with monitoring integration

<pre><code># Factory creates appropriate source type
source = SourceFactory.create_source(config, session)

# Automatic performance monitoring integration
metrics = source.get_performance_metrics()
</code></pre>

<h4>Features</h4>
<ul>
<li>Unified creation interface</li>
<li>Performance monitoring integration</li>
<li>Health checking capabilities</li>
<li>Session pool optimization</li>
</ul>

<h3>3. Performance Monitoring System</h3>
<h4>Location</h4> <code>core/source_system/performance_monitor.py</code>
<h4>Purpose</h4> Real-time metrics and health tracking

<pre><code>@dataclass
class SourceMetrics:
    source_name: str
    total_requests: int = 0
    successful_requests: int = 0
    avg_response_time: float = 0.0
    articles_discovered: int = 0

    @property
    def success_rate(self) -&gt; float:
        return (self.successful_requests / self.total_requests) * 100
</code></pre>

<h4>Capabilities</h4>
<ul>
<li>Real-time performance tracking</li>
<li>Success rate monitoring</li>
<li>Response time analysis</li>
<li>Health status reporting</li>
</ul>

<h3>4. Enhanced Validation Engine</h3>
<h4>Location</h4> <code>core/source_system/validation_engine.py</code>
<h4>Purpose</h4> Comprehensive source validation and quality assurance

<h4>Validation Types</h4>
<ul>
<li><h4>Basic</h4> Configuration syntax and format</li>
<li><h4>Network</h4> Connectivity and accessibility testing</li>
<li><h4>Selectors</h4> CSS selector effectiveness</li>
<li><h4>Deep</h4> Live content validation</li>
</ul>

<pre><code># Comprehensive validation
results = validation_engine.validate_all_sources(configs, deep=True)
report = validation_engine.generate_validation_report(results)
</code></pre>

<h3>5. Interactive Mode System</h3>
<h4>Location</h4> <code>core/interactive.py</code>
<h4>Purpose</h4> User-friendly menu interface for all Capcat operations

<h4>Architecture</h4>
<div class="ascii-art"># Main interactive loop
start_interactive_mode()
├── Main Menu
│   ├── Bundle selection
│   ├── Multi-source fetch
│   ├── Single source fetch
│   ├── Single URL fetch
│   └── Source management submenu
└── Source Management Submenu
    ├── Add RSS source
    ├── Generate config
    ├── Remove sources
    ├── List sources
    └── Test source
</div>

<h4>Key Features</h4>
<ul>
<li><h4>Questionary UI Framework</h4> Terminal-based interactive menus</li>
<li><h4>Logging Suppression</h4> Clean display during navigation</li>
<li><h4>Screen Management</h4> Automatic clearing and formatting</li>
<li><h4>CLI Integration</h4> Constructs argument lists for <code>run_app()</code></li>
<li><h4>Error Handling</h4> Graceful failures with return to menu</li>
</ul>

<h4>Technology Stack</h4>
<pre><code># UI Framework
from questionary import select, checkbox, text, confirm

# Custom styling
custom_style = Style([
    (&#x27;selected&#x27;, &#x27;fg:#d75f00&#x27;),  # Orange theme
    (&#x27;pointer&#x27;, &#x27;fg:#d75f00 bold&#x27;),
])

# Screen control
print(&#x27;\033[2J\033[H&#x27;, end=&#x27;&#x27;)  # Clear screen
</code></pre>

<h4>Integration Points</h4>
<ul>
<li>Uses <code>cli.py</code> functions for source lists and bundles</li>
<li>Calls <code>run_app()</code> from <code>capcat.py</code> for execution</li>
<li>Integrates with source registry for discovery</li>
<li>Uses source management services for add/remove operations</li>
</ul>

<h4>Benefits</h4>
<ul>
<li>Zero command memorization</li>
<li>Visual feedback</li>
<li>Error prevention through validation</li>
<li>Ideal for new users and daily operations</li>
<li>Complements CLI for advanced use cases</li>
</ul>

<p>For detailed documentation, see <a href="interactive-mode.html">Interactive Mode Guide</a>.</p>

<h2>Session Pooling Architecture</h2>

<pre><code># Global session pool for optimal performance
class SessionPool:
    def __init__(self):
        self.session = requests.Session()
        self.session.mount(&#x27;http://&#x27;, HTTPAdapter(pool_connections=20, pool_maxsize=20))
        self.session.mount(&#x27;https://&#x27;, HTTPAdapter(pool_connections=20, pool_maxsize=20))

# All sources share the same optimized session
global_session = get_global_session()
</code></pre>

<h4>Benefits</h4>
<ul>
<li>Connection reuse across sources</li>
<li>Reduced latency</li>
<li>Improved throughput</li>
<li>Resource efficiency</li>
</ul>

<h2>Content Processing Architecture</h2>

<h3>Separated Article and Comment Workflows</h3>

<h4>Design Principle</h4> Complete separation of concerns for better maintainability and error isolation.

<pre><code># Clean separation pattern
class SourceImplementation:
    def fetch_article_content(self, url, ...):
        # Handles ONLY article content extraction and media
        pass

    def fetch_comments(self, comment_url, article_folder):
        # Handles ONLY comment extraction and formatting
        pass
</code></pre>

<h3>Article Processing Pipeline</h3>

<pre><code>Article URL → Content Extraction → Media Processing → Markdown Conversion
                                ↓
                          Fallback Image Detection (if needed)
                                ↓
                          Final Article + Additional Images
</code></pre>

<h4>Key Components</h4>
<ol>
<li><h4>Primary Content Extraction</h4> Uses source-specific or CSS selectors</li>
<li><h4>Media Processing</h4> Downloads images (always) + other media (with --media)</li>
<li><h4>Fallback Image Detection</h4> Automatic activation when &lt; 2 images found</li>
<li><h4>Markdown Generation</h4> Clean HTML-to-Markdown conversion</li>
</ol>

<h3>Fallback Image Detection System</h3>

<h4>Smart Content Recovery</h4> Handles websites without custom configurations by scanning entire pages for content images.

<pre><code># Automatic activation logic
if primary_image_count &lt; 2:
    logger.info(&quot;Activating fallback image detection&quot;)

    # Full page analysis
    additional_images = scan_full_page(
        original_html=full_page_html,
        existing_images=found_images,
        ui_filters=intelligent_filters
    )
</code></pre>

<h4>Intelligent Filtering</h4>
<ul>
<li><h4>UI Element Detection</h4> Removes logos, navigation, ads, social icons</li>
<li><h4>Size Filtering</h4> Skips images &lt; 150px dimensions</li>
<li><h4>Pattern Matching</h4> Filters by class, ID, alt text, and URL patterns</li>
<li><h4>Duplicate Prevention</h4> Avoids re-downloading existing images</li>
</ul>

<h4>Filter Categories</h4>
<pre><code>ui_patterns:
  class_patterns: [logo, icon, avatar, nav, menu, ad, banner, social, share]
  id_patterns: [logo, icon, nav, header, footer, sidebar]
  alt_patterns: [logo, icon, advertisement, navigation, social]
  src_patterns: [logo, icon, avatar, ad, pixel, tracker, beacon, analytics]
</code></pre>

<h3>Comment Processing Pipeline</h3>

<pre><code>Comment URL → Comment Extraction → Thread Building → Markdown Generation
                                                  ↓
                               User Privacy Protection (anonymization)
                                                  ↓
                                      comments.md file
</code></pre>

<h4>Independent Processing Benefits</h4>
<ul>
<li><h4>Error Isolation</h4> Comment failures don&#x27;t affect articles</li>
<li><h4>Clean Interfaces</h4> No parameter pollution</li>
<li><h4>Source Flexibility</h4> Each source handles comments differently</li>
<li><h4>Performance</h4> Parallel processing possible</li>
<li><h4>Maintainability</h4> Clear separation of concerns</li>
</ul>

<h4>Privacy Protection</h4>
<pre><code># Automatic user anonymization
comment_data = {
    &#x27;author&#x27;: &#x27;Anonymous&#x27;,  # Privacy-compliant
    &#x27;original_profile&#x27;: original_profile_link,  # Reference preserved
    &#x27;text&#x27;: cleaned_comment_text,
    &#x27;timestamp&#x27;: comment_timestamp
}
</code></pre>

<h2>Unified Media Processing Architecture</h2>

<h3>Overview</h3>
<p>The Unified Media Processing System eliminates the &quot;whack-a-mole&quot; pattern of fixing image embedding issues source by source. Instead of debugging each source individually, the system provides a single, configurable solution that works across all sources.</p>

<h3>Architecture Components</h3>

<h3>MediaEmbeddingProcessor</h3>
<h4>Location</h4> <code>core/media_embedding_processor.py</code>
<h4>Purpose</h4> Core engine for image extraction, downloading, and URL replacement

<pre><code>from core.unified_media_processor import UnifiedMediaProcessor

# Simple integration for any source
updated_content = UnifiedMediaProcessor.process_article_media(
    content=markdown_content,
    html_content=html_content,
    url=article_url,
    article_folder=article_folder,
    source_name=source_name,
    session=session
)
</code></pre>

<h3>MediaConfigManager</h3>
<h4>Location</h4> <code>core/media_config.py</code>
<h4>Purpose</h4> Source-specific media processing configurations

<pre><code># Predefined configurations for major sources
configs = {
    &#x27;&#x27;: {
        &#x27;hero_image_selectors&#x27;: [&#x27;.featured-image img&#x27;, &#x27;.post-thumbnail img&#x27;],
        &#x27;url_patterns&#x27;: {&#x27;wordpress&#x27;: [&#x27;/wp-content/uploads/&#x27;]},
        &#x27;quality_thresholds&#x27;: {&#x27;min_width&#x27;: 150, &#x27;min_height&#x27;: 150}
    },
    &#x27;&#x27;: {
        &#x27;hero_image_selectors&#x27;: [&#x27;.featured-image img&#x27;, &#x27;.hero-image img&#x27;],
        &#x27;url_patterns&#x27;: {&#x27;&#x27;: [&#x27;i..com/&#x27;, &#x27;.com/wp-content/&#x27;]},
        &#x27;skip_patterns&#x27;: [&#x27;advertisement&#x27;, &#x27;ad-&#x27;, &#x27;sponsored&#x27;]
    }
}
</code></pre>

<h3>Key Features</h3>

<h3>1. Source-Specific Configuration</h3>
<ul>
<li><h4>Hero Image Detection</h4> Custom selectors per source</li>
<li><h4>URL Pattern Recognition</h4> WordPress, CDN, and custom patterns</li>
<li><h4>Quality Filtering</h4> Size and file type thresholds</li>
<li><h4>Skip Patterns</h4> Advertisements and irrelevant images</li>
</ul>

<h3>2. URL Processing Strategies</h3>
<ul>
<li><h4>Protocol-relative URLs</h4> <code>//domain.com/image.jpg</code> → <code>https://domain.com/image.jpg</code></li>
<li><h4>WordPress URLs</h4> <code>/wp-content/uploads/2025/09/image.jpg</code> → <code>images/image.jpg</code></li>
<li><h4>Relative URLs</h4> <code>/media/image.jpg</code> → <code>https://domain.com/media/image.jpg</code></li>
<li><h4>Absolute URLs</h4> Direct processing with domain validation</li>
</ul>

<h3>3. Markdown Integration</h3>
<ul>
<li><h4>BeautifulSoup Parsing</h4> Extract images from original HTML</li>
<li><h4>Regex URL Replacement</h4> Multiple strategies for reliable replacement</li>
<li><h4>Local Path Generation</h4> Consistent <code>images/filename.jpg</code> format</li>
<li><h4>Content Preservation</h4> Maintains alt text and image context</li>
</ul>

<h3>Integration Points</h3>

<p>The unified system integrates at the NewsSourceArticleFetcher level in <code>core/news_source_adapter.py</code>:</p>

<pre><code># Automatic source detection from URL domain
source_name = self._detect_source_from_url(url)

# Process media with unified system
updated_content = UnifiedMediaProcessor.process_article_media(
    content=article_content,
    html_content=response.text,
    url=url,
    article_folder=article_folder_path,
    source_name=source_name,
    session=self.session
)
</code></pre>

<h3>Benefits Achieved</h3>

<ol>
<li><h4>Eliminated &quot;Whack-a-Mole&quot; Pattern</h4> Single fix applies to all 25+ sources</li>
<li><h4>Configurable Processing</h4> Easy to add new sources or adjust existing ones</li>
<li><h4>Consistent Behavior</h4> Same processing logic across all sources</li>
<li><h4>Maintainable Architecture</h4> Centralized instead of scattered fixes</li>
<li><h4>Robust Error Handling</h4> Graceful fallbacks and comprehensive logging</li>
</ol>

<h3>Performance Metrics</h3>

<ul>
<li><h4>Gizmodo</h4> → 27 images</li>
<li><h4>Futurism</h4> → 17 images</li>
<li><h4>IEEE</h4> → 1 image</li>
</ul>

<h2>Performance Characteristics</h2>

<ul>
<li><h4>Development Time</h4> → 15-30 min</li>
<li><h4>Code Lines</h4> → ~10 (YAML)</li>
<li><h4>Maintenance</h4> → Config update</li>
<li><h4>Flexibility</h4> → Limited</li>
<li><h4>Performance</h4> → Excellent</li>
</ul>

<h2>Simple Protection System</h2>

<h3>Overview</h3>
<p>The Simple Protection System provides efficient protection against link aggregators and oversized images using clear, maintainable rules. It replaces the complex Website Classifier with simple heuristics that are easy to understand and modify.</p>

<h3>Protection Rules</h3>

<div class="ascii-art">┌──────────────────────────────────────────────────────────────────┐
│                      Simple Protection Rules                    │
├──────────────────────┬─────────────────────────────────────────────┤
│ Protection Type      │ Rule                                        │
├──────────────────────┼─────────────────────────────────────────────┤
│ Aggregator Detection │ Link density &gt; 15% OR &gt; 10 external domains│
│ Per-Image Filtering  │ Skip images &gt; 5MB OR &lt; 150px               │
│ Image Count Limit    │ Maximum 20 images per article              │
│ --media Flag         │ Increases limit to 1000 images             │
└──────────────────────┴─────────────────────────────────────────────┘
</div>

<h3>Simple Detection Logic</h3>

<h4>Aggregator Detection</h4>
<ul>
<li>Link density &gt; 15% of content (links per word count)</li>
<li>Links to &gt; 10 different external domains</li>
<li>Navigation links automatically excluded from analysis</li>
</ul>

<h4>Per-Image Filtering</h4>
<ul>
<li>HEAD request checks image size before download</li>
<li>Skip images &gt; 5MB (unless --media flag used)</li>
<li>Skip images &lt; 150px (likely icons/decorative)</li>
<li>Skip non-image content types</li>
</ul>

<h3>Real-World Protection Examples</h3>

<h4>Aggregator Site Example</h4>
<pre><code>Input: News aggregator with many external links
Analysis:
  - Word count: 200, Links: 35 → Link density: 17.5% (above 15%)
  - External domains: 12 (above 10 threshold)
Result: BLOCKED (aggregator detected)
</code></pre>

<h4>Normal Article Example</h4>
<pre><code>Input: Technical article about React optimization
Analysis:
  - Word count: 800, Links: 5 → Link density: 0.6% (below 15%)
  - External domains: 2 (below 10 threshold)
Result: ALLOWED (up to 20 images)
</code></pre>

<h3>--media Flag Integration</h3>

<pre><code># Normal behavior (without --media)
max_images = 20  # Standard limit

# With --media flag
if media_enabled:
    max_images = 1000  # Very high limit
    # Per-image 5MB limit still applies for safety
</code></pre>

<h4>Edge Case Handling</h4>
<ul>
<li><code>--media</code> flag increases image count limit to 1000</li>
<li>Per-image size checking still applies for safety</li>
<li>Aggregator detection still blocks problematic sites</li>
<li>Simple, predictable behavior</li>
</ul>

<h3>Architecture Integration</h3>

<h4>Location</h4> <code>core/simple_protection.py</code>
<h4>Integration Point</h4> <code>core/image_processor.py</code>

<pre><code># Simple protection check during image processing
protection_result = self.protection.check_content(html_content, base_url)

# Skip if aggregator detected
if protection_result.is_aggregator:
    logger.warning(f&quot;Skipping aggregator site: {base_url}&quot;)
    return {}
</code></pre>

<h4>Performance Characteristics</h4>
<ul>
<li><h4>Fast Analysis</h4> Content metrics extracted in ~10ms</li>
<li><h4>No Network Calls</h4> Uses only downloaded content</li>
<li><h4>Memory Efficient</h4> Processes content in streaming fashion</li>
<li><h4>Logging</h4> Detailed classification reasoning for debugging</li>
</ul>

<h2>Configuration Management</h2>

<h4>Hierarchy</h4> (highest to lowest priority):
<ol>
<li>Command-line arguments</li>
<li>Environment variables</li>
<li>Configuration files (<code>capcat.yml</code>)</li>
<li>Default values</li>
</ol>

<pre><code># Example: capcat.yml
network:
  connect_timeout: 10
  read_timeout: 8
  user_agent: &quot;Mozilla/5.0 (compatible; Capcat/2.0)&quot;

processing:
  max_workers: 8
  download_images: true
  download_videos: false

logging:
  default_level: &quot;INFO&quot;
  use_colors: true
</code></pre>

<h2>Template System Architecture</h2>

<h4>Universal HTML Generation</h4> Consistent navigation and professional output across all sources.

<h3>Template Components</h3>

<div class="ascii-art">templates/
├── article-with-comments.html     # For sources supporting comments (HN, Lobsters, LessWrong)
├── article-no-comments.html       # For sources without comments (BBC, CNN, Nature, etc.)
└── comments-with-navigation.html  # For all comments pages (Back to Article button)
</div>

<h3>Template Configuration</h3>

<pre><code># Source template configuration
template:
  variant: &quot;article-with-comments&quot;  # or &quot;article-no-comments&quot;
  navigation:
    back_to_news_url: &quot;../../news.html&quot;
    back_to_news_text: &quot;Back to News&quot;
    has_comments: true
    comments_url: &quot;comments.html&quot;
    comments_text: &quot;View Comments&quot;
</code></pre>

<h3>Navigation Logic</h3>

<ul>
<li><h4>Article Pages (with comments)</h4> &quot;Back to News&quot; + &quot;View Comments&quot;</li>
<li><h4>Article Pages (no comments)</h4> &quot;Back to News&quot; only</li>
<li><h4>Comments Pages</h4> &quot;Back to Article&quot; only</li>
</ul>

<h3>Source Detection</h3>

<p>Template system automatically detects 30+ source patterns:</p>
<ul>
<li>Hacker-News, Lobsters, LessWrong → <code>article-with-comments</code></li>
<li>BBC, CNN, Nature → <code>article-no-comments</code></li>
<li>All comments pages → <code>comments-with-navigation</code></li>
</ul>

<h3>Benefits</h3>

<ul>
<li><h4>100% Navigation Consistency</h4> Same patterns across all sources</li>
<li><h4>Professional Appearance</h4> Template-driven HTML with themes</li>
<li><h4>Easy Maintenance</h4> Update all sources by modifying templates</li>
<li><h4>Scalable</h4> Add new sources with simple YAML configuration</li>
</ul>

<h2>Testing Architecture</h2>

<h4>Test Levels</h4>
<ol>
<li><h4>Unit Tests</h4> Individual component testing</li>
<li><h4>Integration Tests</h4> Cross-component functionality</li>
<li><h4>Source Tests</h4> Individual source validation</li>
<li><h4>System Tests</h4> End-to-end workflow validation</li>
</ol>

<pre><code># Comprehensive testing framework
python test_comprehensive_sources.py  # Tests all 20 sources
python test_validation_engine.py      # Tests validation system
python test_performance_monitor.py    # Tests monitoring system
</code></pre>

<h2>Extension Points</h2>

<h3>Adding New Config-Driven Sources</h3>
<pre><code># 1. Create YAML configuration
# sources/active/config_driven/configs/newsource.yaml
display_name: &quot;New Source&quot;
base_url: &quot;https://newsource.com/&quot;
article_selectors: [&quot;.headline a&quot;]
content_selectors: [&quot;.article-content&quot;]

# 2. Source automatically discovered and available
</code></pre>

<h3>Adding New Custom Sources</h3>
<div class="ascii-art"># 1. Create source directory and files
# sources/active/custom/newsource/
# ├── source.py          # BaseSource implementation
# └── config.yaml        # Source configuration

# 2. Implement BaseSource contract
class NewSource(BaseSource):
    def get_articles(self, count=30):
        # Custom implementation
        pass
</div>

<h2>Error Handling Strategy</h2>

<h4>Graceful Degradation</h4>
<ul>
<li>Individual source failures don&#x27;t affect others</li>
<li>Partial success reported clearly</li>
<li>Detailed error logging for debugging</li>
<li>Automatic retry mechanisms for transient failures</li>
</ul>

<h4>Error Categories</h4>
<ul>
<li><h4>Network</h4> Timeouts, connection failures</li>
<li><h4>Parsing</h4> Invalid HTML, missing selectors</li>
<li><h4>Configuration</h4> Invalid YAML, missing fields</li>
<li><h4>Logic</h4> Custom source implementation errors</li>
</ul>

<h2>HTML Generation Architecture</h2>

<p>Capcat 2.0 features a <h4>compartmentalized HTML generation system</h4> that replaces monolithic conditional logic with source-specific configurations and templates.</p>

<h3>Architecture Overview</h3>

<div class="ascii-art">┌─────────────────────────────────────────────────────────────┐
│                 HTML Generation System                     │
├─────────────────────────────────────────────────────────────┤
│  Factory Pattern                                           │
│  ├── HTMLGeneratorFactory                                  │
│  └── Source-specific Generator Instances                   │
├─────────────────────────────────────────────────────────────┤
│  Base System                                               │
│  ├── BaseHTMLGenerator (Abstract)                          │
│  ├── Base Templates ({{}} syntax)                          │
│  └── Configuration Schema                                  │
├─────────────────────────────────────────────────────────────┤
│  Source-Specific Implementations                           │
│  ├── htmlgen/hn/                                          │
│  │   ├── config.yaml                                      │
│  │   ├── generator.py                                     │
│  │   └── templates/ (overrides)                           │
│  ├── htmlgen//                                   │
│  └── htmlgen/lb/                                          │
└─────────────────────────────────────────────────────────────┘
</div>

<h3>Key Features</h3>

<h4>1. Configuration-Driven Behavior</h4>
<pre><code># htmlgen/hn/config.yaml
comments:
  enabled: true
  pattern: &#x27;\*\*Anonymous\*\*\s*\(\[profile\]\([^)]*\)\)&#x27;
  conditional_display: true

navigation:
  breadcrumb_style: &quot;technical&quot;
  date_format: &quot;YYYY-MM-DD&quot;

layout:
  template_set: &quot;base&quot;
  custom_css_classes:
    - &quot;hn-style&quot;
    - &quot;tech-focused&quot;
</code></pre>

<h4>2. Template System with Override Capability</h4>
<ul>
<li><h4>Base Templates</h4> <code>htmlgen/base/templates/</code> using clean <code>{{}}</code> syntax</li>
<li><h4>Source Overrides</h4> <code>htmlgen/[source]/templates/</code> for custom layouts</li>
<li><h4>Fallback Logic</h4> Jinja2 with string replacement fallback</li>
</ul>

<h4>3. Privacy-Compliant Comment Processing</h4>
<pre><code>def count_comments(self, comments_file: Path) -&gt; int:
    pattern = self.source_config[&#x27;comments&#x27;][&#x27;pattern&#x27;]
    matches = re.findall(pattern, content)
    return len(matches)
</code></pre>

<h4>4. Validation and Testing</h4>
<ul>
<li>JSON Schema validation for all configurations</li>
<li>Comprehensive test suite with 100% pass rate</li>
<li>Source-specific pattern validation</li>
</ul>

<h3>Benefits</h3>

<ul>
<li><h4>Maintainability</h4> No more monolithic conditional logic</li>
<li><h4>Extensibility</h4> Easy to add new sources with YAML config</li>
<li><h4>Consistency</h4> Standardized configuration schema</li>
<li><h4>Privacy</h4> Built-in anonymization pattern support</li>
<li><h4>Performance</h4> Template caching and optimization</li>
<li><h4>Testing</h4> Isolated testing per source</li>
</ul>

<h3>Usage Example</h3>

<pre><code># Automatic factory instantiation
generator = HTMLGeneratorFactory.create_generator(&quot;hn&quot;)

# Source-specific behavior from config
comment_count = generator.count_comments(comments_file)
should_show = generator.should_show_comment_link(comment_count)

# Template rendering with source customization
html_content = generator.render_template(&quot;article.html&quot;, context)
</code></pre>

<h2>Privacy &amp; Anonymization Architecture</h2>

<h4>Comment Processing Pipeline</h4>
<ol>
<li><h4>Collection</h4> Comments fetched from source APIs</li>
<li><h4>Anonymization</h4> Usernames replaced with &quot;Anonymous&quot;</li>
<li><h4>Link Preservation</h4> Profile URLs preserved for reference</li>
<li><h4>Pattern Recognition</h4> Source-specific regex patterns match anonymized format</li>
<li><h4>HTML Generation</h4> Templates render privacy-compliant output</li>
</ol>

<h4>Legal Compliance Features</h4>
<ul>
<li>No personal username storage</li>
<li>Anonymous-only display in all outputs</li>
<li>Functional profile links preserved</li>
<li>Transparent privacy policy</li>
<li>Source attribution maintained</li>
</ul>

<h2>Design Principles</h2>

<ol>
<li><h4>Separation of Concerns</h4> Config vs logic clearly separated</li>
<li><h4>Single Responsibility</h4> Each component has focused purpose</li>
<li><h4>Open/Closed</h4> Open for extension, closed for modification</li>
<li><h4>DRY</h4> No code duplication across sources</li>
<li><h4>Performance</h4> Session pooling and connection optimization</li>
<li><h4>Testability</h4> Comprehensive testing at all levels</li>
<li><h4>Maintainability</h4> Clear patterns and documentation</li>
<li><h4>Privacy by Design</h4> Built-in anonymization and compliance</li>
<li><h4>Template Modularity</h4> Reusable components with override capability</li>
</ol>



<em>This architecture provides the foundation for scalable, maintainable news source management with optimal performance characteristics.</em>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
      // Primary colors from design system (Capcat orange palette)
      primaryColor: '#FFD4B7',           // --orange-200
      primaryTextColor: '#201419',       // --ink
      primaryBorderColor: '#F1540E',     // --orange-500 / --accent-primary

      // Line and edge colors
      lineColor: '#58444c',              // --ink-medium

      // Secondary colors
      secondaryColor: '#FFEADB',         // --orange-100
      tertiaryColor: '#f9f8ed',          // --accent-cream-primary

      // Text colors
      textColor: '#201419',              // --ink
      mainBkg: '#FAF8EE',                // --cream

      // Node styling
      nodeBorder: '#F1540E',             // --accent-primary
      clusterBkg: '#faf2e7',             // --accent-cream-light
      clusterBorder: '#D44400',          // --orange-600 / --accent-hover

      // Font
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      fontSize: '16px'
    },
    flowchart: {
      nodeSpacing: 50,
      rankSpacing: 50,
      padding: 15,
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis'
    }
  });

  // Add copy buttons to Mermaid diagrams after rendering
  document.addEventListener('DOMContentLoaded', function() {
    const mermaidDivs = document.querySelectorAll('.mermaid');

    mermaidDivs.forEach(function(mermaidDiv) {
      // Get the original Mermaid source code
      const mermaidSource = mermaidDiv.textContent;

      // Create container wrapper
      const container = document.createElement('div');
      container.className = 'mermaid-container';

      // Create copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'mermaid-copy-btn';
      copyBtn.textContent = 'Copy Mermaid Code';
      copyBtn.setAttribute('title', 'Copy diagram code for Draw.io, Mermaid Live, etc.');

      copyBtn.addEventListener('click', function() {
        navigator.clipboard.writeText(mermaidSource).then(function() {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');

          setTimeout(function() {
            copyBtn.textContent = 'Copy Mermaid Code';
            copyBtn.classList.remove('copied');
          }, 2000);
        });
      });

      // Wrap the mermaid div in container and add button
      mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
      container.appendChild(mermaidDiv);
      container.appendChild(copyBtn);
    });
  });
</script>
    <script src="../js/main.js"></script>

            
<nav class="chapter-navigation" aria-label="Chapter navigation">
    <div class="next-chapter-content">
        <span class="next-chapter-label">Next Chapter</span>
        <span class="next-chapter-arrow" aria-hidden="true">→</span>
        <a href="DIAGRAMS_INDEX.html" class="next-chapter-link" rel="next">Architecture Diagrams</a>
    </div>
</nav>
</div>
        </div>
    </div>

    <!-- Footer -->
    {% include footer.html %}

    <!-- Back to Top Button -->
    <button id="backToTopBtn" title="Go to top">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
        </svg>
    </button>  </body>
