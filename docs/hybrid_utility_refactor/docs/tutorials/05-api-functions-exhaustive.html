<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Functions Comprehensive Reference</title>
    <link rel="stylesheet" href="../../css/design-system.css">
    <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
    <!-- Header -->
    {% include header.html %}


    <div class="doc-container">
        <div class="container">
            <div class="doc-content">

<div class="nav-breadcrumb"><a href="../index.html">Documentation Home</a> / tutorials</div>
<h1>API Functions Comprehensive Reference</h1>

<p>Complete documentation of EVERY public API function, method, class, and parameter in Capcat&#x27;s codebase.</p>

<p>Source: Application/core/, Application/docs/api-reference.md</p>

<h2>Module Organization</h2>

<h3>Core Modules</h3>

<ul>
<li><h4>source_system</h4> → core/source_system/</li>
<li><h4>article_fetcher</h4> → core/article_fetcher.py</li>
<li><h4>media_processor</h4> → core/media_processor.py</li>
<li><h4>formatter</h4> → core/formatter.py</li>
<li><h4>config</h4> → core/config.py</li>
<li><h4>logging_config</h4> → core/logging_config.py</li>
<li><h4>progress</h4> → core/progress.py</li>
<li><h4>utils</h4> → core/utils.py</li>
<li><h4>downloader</h4> → core/downloader.py</li>
<li><h4>retry</h4> → core/retry.py</li>
<li><h4>rate_limiter</h4> → core/rate_limiter.py</li>
</ul>

<h2>Source System API</h2>

<h3>SourceRegistry Class</h3>

<p>Location: Application/core/source_system/source_registry.py:28</p>

<h4>Import:</h4>
<pre><code>from core.source_system.source_registry import SourceRegistry, get_source_registry
</code></pre>

<h3>Constructor</h3>

<h4>Signature:</h4>
<pre><code>def __init__(self, sources_dir: str = None)
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>sources_dir</code> (str, optional) - Path to sources directory</li>
<li>Default: Application/sources/active/</li>
<li>Must contain config_driven/ and custom/ subdirectories</li>
</ul>

<h4>Returns:</h4> SourceRegistry instance

<h4>Example:</h4>
<pre><code># Use default directory
registry = SourceRegistry()

# Use custom directory
registry = SourceRegistry(&quot;/custom/sources/path&quot;)
</code></pre>

<h3>Methods</h3>

<h4>discover_sources()</h4>

<h4>Signature:</h4>
<pre><code>def discover_sources(self) -&gt; Dict[str, SourceConfig]
</code></pre>

<h4>Returns:</h4> Dict[str, SourceConfig] - Source names mapped to configurations

<h4>Raises:</h4> SourceError - If discovery fails

<h4>Behavior:</h4>
<ol>
<li>Clears existing source data</li>
<li>Scans config_driven/configs/ for YAML/JSON files</li>
<li>Scans custom/ for Python source implementations</li>
<li>Validates all discovered sources</li>
<li>Returns dictionary of valid sources</li>
</ol>

<h4>Example:</h4>
<pre><code>registry = SourceRegistry()
sources = registry.discover_sources()

print(f&quot;Discovered {len(sources)} sources:&quot;)
for name, config in sources.items():
    print(f&quot;  {name}: {config.display_name} ({config.category})&quot;)
</code></pre>

<h4>get_source()</h4>

<h4>Signature:</h4>
<pre><code>def get_source(self, source_name: str, session: requests.Session = None) -&gt; BaseSource
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str, required) - Source identifier</li>
<li><code>session</code> (requests.Session, optional) - HTTP session for connection pooling</li>
</ul>

<h4>Returns:</h4> BaseSource - Instantiated source object

<h4>Raises:</h4> SourceError - If source not found or cannot be instantiated

<h4>Caching:</h4> Instances are cached for reuse

<h4>Example:</h4>
<pre><code>registry = get_source_registry()

# Get source with default session
source = registry.get_source(&#x27;hn&#x27;)

# Get source with custom session
import requests
custom_session = requests.Session()
source = registry.get_source(&#x27;bbc&#x27;, session=custom_session)

# Use source
articles = source.discover_articles(count=10)
</code></pre>

<h4>get_available_sources()</h4>

<h4>Signature:</h4>
<pre><code>def get_available_sources(self) -&gt; List[str]
</code></pre>

<h4>Returns:</h4> List[str] - List of all source identifiers

<h4>Auto-discovery:</h4> Calls discover_sources() if not already loaded

<h4>Example:</h4>
<pre><code>registry = get_source_registry()
sources = registry.get_available_sources()

print(f&quot;Available sources ({len(sources)}):&quot;)
for source_id in sorted(sources):
    print(f&quot;  - {source_id}&quot;)
</code></pre>

<h4>get_source_config()</h4>

<h4>Signature:</h4>
<pre><code>def get_source_config(self, source_name: str) -&gt; Optional[SourceConfig]
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str, required) - Source identifier</li>
</ul>

<h4>Returns:</h4> Optional[SourceConfig] - Configuration or None if not found

<h4>Example:</h4>
<pre><code>registry = get_source_registry()
config = registry.get_source_config(&#x27;hn&#x27;)

if config:
    print(f&quot;Name: {config.display_name}&quot;)
    print(f&quot;URL: {config.base_url}&quot;)
    print(f&quot;Category: {config.category}&quot;)
    print(f&quot;Timeout: {config.timeout}s&quot;)
else:
    print(&quot;Source not found&quot;)
</code></pre>

<h4>get_sources_by_category()</h4>

<h4>Signature:</h4>
<pre><code>def get_sources_by_category(self, category: str) -&gt; List[str]
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>category</code> (str, required) - Category name (tech, news, science, ai, sports, etc.)</li>
</ul>

<h4>Returns:</h4> List[str] - Source identifiers in category

<h4>Example:</h4>
<pre><code>registry = get_source_registry()

# Get all tech sources
tech_sources = registry.get_sources_by_category(&#x27;tech&#x27;)
print(f&quot;Tech sources: {&#x27;, &#x27;.join(tech_sources)}&quot;)

# Get all categories
categories = {}
for source_id in registry.get_available_sources():
    config = registry.get_source_config(source_id)
    if config.category not in categories:
        categories[config.category] = []
    categories[config.category].append(source_id)

for category, sources in sorted(categories.items()):
    print(f&quot;{category}: {len(sources)} sources&quot;)
</code></pre>

<h4>validate_all_sources()</h4>

<h4>Signature:</h4>
<pre><code>def validate_all_sources(self, deep_validation: bool = False) -&gt; Dict[str, List[str]]
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>deep_validation</code> (bool, optional) - Whether to perform network connectivity tests</li>
<li>False: Only validate configuration fields</li>
<li>True: Test network connectivity and article discovery</li>
</ul>

<h4>Returns:</h4> Dict[str, List[str]] - Source names mapped to error lists (empty list = valid)

<h4>Example:</h4>
<pre><code>registry = get_source_registry()

# Basic validation only
errors = registry.validate_all_sources(deep_validation=False)

# Deep validation with network tests
errors = registry.validate_all_sources(deep_validation=True)

# Report errors
for source_name, error_list in errors.items():
    if error_list:
        print(f&quot;{source_name}: FAILED&quot;)
        for error in error_list:
            print(f&quot;  - {error}&quot;)
    else:
        print(f&quot;{source_name}: OK&quot;)
</code></pre>

<h3>Global Registry Function</h3>

<h4>get_source_registry()</h4>

<h4>Signature:</h4>
<pre><code>def get_source_registry() -&gt; SourceRegistry
</code></pre>

<h4>Returns:</h4> SourceRegistry - Global singleton registry instance

<h4>Behavior:</h4>
<ul>
<li>Returns cached instance if exists</li>
<li>Creates new instance and runs discovery on first call</li>
<li>Thread-safe singleton pattern</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.source_system.source_registry import get_source_registry

# Get global registry
registry = get_source_registry()

# All calls return same instance
registry1 = get_source_registry()
registry2 = get_source_registry()
assert registry1 is registry2  # True
</code></pre>

<h2>BaseSource Abstract Class</h2>

<p>Location: Application/core/source_system/base_source.py:78</p>

<h4>Import:</h4>
<pre><code>from core.source_system.base_source import BaseSource, SourceConfig, Article
</code></pre>

<h3>Constructor</h3>

<h4>Signature:</h4>
<pre><code>def __init__(self, config: SourceConfig, session: requests.Session = None)
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>config</code> (SourceConfig, required) - Source configuration</li>
<li><code>session</code> (requests.Session, optional) - HTTP session</li>
</ul>

<h4>Attributes Created:</h4>
<ul>
<li><code>self.config</code> - SourceConfig instance</li>
<li><code>self.session</code> - requests.Session instance</li>
<li><code>self.logger</code> - Logger instance</li>
</ul>

<h3>Abstract Properties</h3>

<h4>source_type</h4>

<h4>Signature:</h4>
<pre><code>@property
@abstractmethod
def source_type(self) -&gt; str
</code></pre>

<h4>Returns:</h4> str - &quot;config_driven&quot; or &quot;custom&quot;

<h4>Example Implementation:</h4>
<pre><code>@property
def source_type(self) -&gt; str:
    return &quot;custom&quot;
</code></pre>

<h3>Abstract Methods</h3>

<h4>discover_articles()</h4>

<h4>Signature:</h4>
<pre><code>@abstractmethod
def discover_articles(self, count: int) -&gt; List[Article]
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>count</code> (int, required) - Maximum number of articles to discover</li>
</ul>

<h4>Returns:</h4> List[Article] - Article objects with title, url, optional metadata

<h4>Raises:</h4> SourceError - If discovery fails

<h4>Example Implementation:</h4>
<pre><code>def discover_articles(self, count: int) -&gt; List[Article]:
    response = self.session.get(self.config.base_url)
    soup = BeautifulSoup(response.text, &#x27;html.parser&#x27;)

    articles = []
    for link in soup.select(&#x27;.article-link&#x27;)[:count]:
        articles.append(Article(
            title=link.get_text(strip=True),
            url=self._resolve_url(link[&#x27;href&#x27;]),
            summary=link.get(&#x27;aria-label&#x27;, &#x27;&#x27;),
            tags=[&#x27;general&#x27;]
        ))

    self.logger.info(f&quot;Discovered {len(articles)} articles&quot;)
    return articles
</code></pre>

<h4>fetch_article_content()</h4>

<h4>Signature:</h4>
<pre><code>@abstractmethod
def fetch_article_content(
    self,
    article: Article,
    output_dir: str,
    progress_callback: Callable = None
) -&gt; Tuple[bool, Optional[str]]
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>article</code> (Article, required) - Article to fetch</li>
<li><code>output_dir</code> (str, required) - Directory to save content</li>
<li><code>progress_callback</code> (Callable, optional) - Progress update function</li>
</ul>

<h4>Returns:</h4> Tuple[bool, Optional[str]]
<ul>
<li>(True, &quot;/path/to/article&quot;) - Success</li>
<li>(False, None) - Failure</li>
</ul>

<h4>Raises:</h4> SourceError - If fetch fails

<h4>Example Implementation:</h4>
<pre><code>def fetch_article_content(
    self,
    article: Article,
    output_dir: str,
    progress_callback=None
) -&gt; Tuple[bool, Optional[str]]:
    try:
        # Fetch content
        response = self.session.get(article.url)
        soup = BeautifulSoup(response.text, &#x27;html.parser&#x27;)

        # Extract content
        content = soup.select_one(&#x27;.article-content&#x27;)
        if not content:
            self.logger.error(f&quot;No content found for {article.url}&quot;)
            return False, None

        # Convert to markdown
        from core.formatter import html_to_markdown
        markdown = html_to_markdown(str(content), article.url)

        # Save to file
        os.makedirs(output_dir, exist_ok=True)
        article_path = os.path.join(output_dir, &#x27;article.md&#x27;)

        with open(article_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:
            f.write(f&quot;# {article.title}\n\n&quot;)
            f.write(f&quot;URL: {article.url}\n\n&quot;)
            f.write(markdown)

        self.logger.info(f&quot;Saved article to {article_path}&quot;)
        return True, article_path

    except Exception as e:
        self.logger.error(f&quot;Failed to fetch article: {e}&quot;)
        return False, None
</code></pre>

<h3>Concrete Methods</h3>

<h4>fetch_comments()</h4>

<h4>Signature:</h4>
<pre><code>def fetch_comments(
    self,
    article: Article,
    output_dir: str,
    progress_callback: Callable = None
) -&gt; bool
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>article</code> (Article, required) - Article to fetch comments for</li>
<li><code>output_dir</code> (str, required) - Directory to save comments</li>
<li><code>progress_callback</code> (Callable, optional) - Progress update function</li>
</ul>

<h4>Returns:</h4> bool - True if comments fetched, False otherwise

<h4>Behavior:</h4>
<ul>
<li>Returns False immediately if <code>supports_comments</code> is False</li>
<li>Delegates to <code>_fetch_comments_impl()</code> if supported</li>
<li>Optional method - not required for all sources</li>
</ul>

<h4>Example Usage:</h4>
<pre><code>source = registry.get_source(&#x27;hn&#x27;)
article = Article(
    title=&quot;Example&quot;,
    url=&quot;https://news.ycombinator.com/item?id=12345&quot;,
    comment_url=&quot;https://news.ycombinator.com/item?id=12345&quot;
)

success = source.fetch_comments(article, &quot;/output/dir&quot;)
if success:
    print(&quot;Comments fetched successfully&quot;)
</code></pre>

<h4>validate_config()</h4>

<h4>Signature:</h4>
<pre><code>def validate_config(self) -&gt; List[str]
</code></pre>

<h4>Returns:</h4> List[str] - Validation error messages (empty = valid)

<h4>Validation Checks:</h4>
<ul>
<li>Name not empty</li>
<li>Display name not empty</li>
<li>Base URL not empty and starts with http:// or https://</li>
<li>Timeout &gt; 0</li>
<li>Rate limit &gt;= 0</li>
</ul>

<h4>Example:</h4>
<pre><code>source = registry.get_source(&#x27;hn&#x27;)
errors = source.validate_config()

if errors:
    print(&quot;Validation failed:&quot;)
    for error in errors:
        print(f&quot;  - {error}&quot;)
else:
    print(&quot;Configuration is valid&quot;)
</code></pre>

<h2>Data Classes</h2>

<h3>SourceConfig</h3>

<p>Location: Application/core/source_system/base_source.py:14</p>

<h4>Import:</h4>
<pre><code>from core.source_system.base_source import SourceConfig
</code></pre>

<h4>Constructor:</h4>
<pre><code>@dataclass
class SourceConfig:
    name: str
    display_name: str
    base_url: str
    timeout: float = 10.0
    rate_limit: float = 1.0
    supports_comments: bool = False
    has_comments: bool = False
    category: str = &quot;general&quot;
    custom_config: Dict[str, Any] = None
</code></pre>

<h4>Fields:</h4>
<ul>
<li><code>name</code> (str, required) - Source identifier</li>
<li><code>display_name</code> (str, required) - Human-readable name</li>
<li><code>base_url</code> (str, required) - Base URL</li>
<li><code>timeout</code> (float, default=10.0) - Request timeout seconds</li>
<li><code>rate_limit</code> (float, default=1.0) - Minimum seconds between requests</li>
<li><code>supports_comments</code> (bool, default=False) - Comments support flag</li>
<li><code>has_comments</code> (bool, default=False) - Comments enabled flag</li>
<li><code>category</code> (str, default=&quot;general&quot;) - Category name</li>
<li><code>custom_config</code> (Dict, default=None) - Additional configuration</li>
</ul>

<h4>Methods:</h4>

<h4>to_dict()</h4>

<h4>Signature:</h4>
<pre><code>def to_dict(self) -&gt; Dict[str, Any]
</code></pre>

<h4>Returns:</h4> Dict[str, Any] - Dictionary representation

<h4>Example:</h4>
<pre><code>config = SourceConfig(
    name=&quot;example&quot;,
    display_name=&quot;Example News&quot;,
    base_url=&quot;https://example.com/&quot;,
    category=&quot;tech&quot;
)

config_dict = config.to_dict()
print(config_dict)
# {
#   &#x27;name&#x27;: &#x27;example&#x27;,
#   &#x27;display_name&#x27;: &#x27;Example News&#x27;,
#   &#x27;base_url&#x27;: &#x27;https://example.com/&#x27;,
#   &#x27;timeout&#x27;: 10.0,
#   &#x27;rate_limit&#x27;: 1.0,
#   &#x27;supports_comments&#x27;: False,
#   &#x27;has_comments&#x27;: False,
#   &#x27;category&#x27;: &#x27;tech&#x27;
# }
</code></pre>

<h3>Article</h3>

<p>Location: Application/core/source_system/base_source.py:59</p>

<h4>Import:</h4>
<pre><code>from core.source_system.base_source import Article
</code></pre>

<h4>Constructor:</h4>
<pre><code>@dataclass
class Article:
    title: str
    url: str
    comment_url: Optional[str] = None
    author: Optional[str] = None
    published_date: Optional[str] = None
    summary: Optional[str] = None
    tags: List[str] = None
</code></pre>

<h4>Fields:</h4>
<ul>
<li><code>title</code> (str, required) - Article title</li>
<li><code>url</code> (str, required) - Article URL</li>
<li><code>comment_url</code> (Optional[str], default=None) - Comments URL</li>
<li><code>author</code> (Optional[str], default=None) - Author name</li>
<li><code>published_date</code> (Optional[str], default=None) - Publication date</li>
<li><code>summary</code> (Optional[str], default=None) - Article summary</li>
<li><code>tags</code> (List[str], default=None) - Article tags</li>
</ul>

<h4>Example:</h4>
<pre><code>article = Article(
    title=&quot;Breaking News: AI Breakthrough&quot;,
    url=&quot;https://example.com/article/123&quot;,
    comment_url=&quot;https://example.com/article/123/comments&quot;,
    author=&quot;John Doe&quot;,
    published_date=&quot;2025-11-25&quot;,
    summary=&quot;Researchers announce major AI advancement...&quot;,
    tags=[&quot;ai&quot;, &quot;tech&quot;, &quot;research&quot;]
)

print(f&quot;{article.title} by {article.author}&quot;)
print(f&quot;URL: {article.url}&quot;)
print(f&quot;Tags: {&#x27;, &#x27;.join(article.tags)}&quot;)
</code></pre>

<h2>ArticleFetcher API</h2>

<p>Location: Application/core/article_fetcher.py:110</p>

<h4>Import:</h4>
<pre><code>from core.article_fetcher import ArticleFetcher, convert_html_with_timeout
</code></pre>

<h3>Global Functions</h3>

<h4>convert_html_with_timeout()</h4>

<h4>Signature:</h4>
<pre><code>def convert_html_with_timeout(
    html_content: str,
    url: str,
    timeout: int = 30
) -&gt; str
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>html_content</code> (str, required) - Raw HTML to convert</li>
<li><code>url</code> (str, required) - Source URL for logging</li>
<li><code>timeout</code> (int, default=30) - Maximum conversion time seconds</li>
</ul>

<h4>Returns:</h4> str - Converted Markdown content (empty string on error)

<h4>Thread Safety:</h4> Thread-safe, can be called concurrently

<h4>Behavior:</h4>
<ul>
<li>Validates input (non-empty string)</li>
<li>Executes conversion in isolated thread</li>
<li>Times out after specified seconds</li>
<li>Returns empty string on timeout or error</li>
<li>Logs all failures</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.article_fetcher import convert_html_with_timeout

html = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;
markdown = convert_html_with_timeout(html, &quot;https://example.com&quot;)

print(markdown)
# # Title
#
# Content
</code></pre>

<h4>set_global_update_mode()</h4>

<h4>Signature:</h4>
<pre><code>def set_global_update_mode(update_mode: bool)
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>update_mode</code> (bool, required) - Enable/disable update mode</li>
</ul>

<h4>Behavior:</h4>
<ul>
<li>Sets global flag for all ArticleFetcher instances</li>
<li>Controls whether existing articles are overwritten</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.article_fetcher import set_global_update_mode

# Enable update mode
set_global_update_mode(True)

# Process articles (will overwrite existing)
# ...

# Disable update mode
set_global_update_mode(False)
</code></pre>

<h4>get_global_update_mode()</h4>

<h4>Signature:</h4>
<pre><code>def get_global_update_mode() -&gt; bool
</code></pre>

<h4>Returns:</h4> bool - Current update mode status

<h4>Example:</h4>
<pre><code>from core.article_fetcher import get_global_update_mode

if get_global_update_mode():
    print(&quot;Update mode is enabled - will overwrite existing articles&quot;)
else:
    print(&quot;Update mode is disabled - will skip existing articles&quot;)
</code></pre>

<h2>Configuration API</h2>

<p>Location: Application/core/config.py</p>

<h4>Import:</h4>
<pre><code>from core.config import get_config, load_config, FetchNewsConfig
from core.config import NetworkConfig, ProcessingConfig, LoggingConfig, UIConfig
</code></pre>

<h3>Global Functions</h3>

<h4>get_config()</h4>

<h4>Signature:</h4>
<pre><code>def get_config() -&gt; FetchNewsConfig
</code></pre>

<h4>Returns:</h4> FetchNewsConfig - Global configuration instance

<h4>Behavior:</h4>
<ul>
<li>Returns cached config if already loaded</li>
<li>Creates new ConfigManager and loads config on first call</li>
<li>Searches default config file locations</li>
<li>Loads environment variables</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.config import get_config

config = get_config()
print(f&quot;Max workers: {config.processing.max_workers}&quot;)
print(f&quot;Timeout: {config.network.connect_timeout}s&quot;)
print(f&quot;Log level: {config.logging.default_level}&quot;)
</code></pre>

<h4>load_config()</h4>

<h4>Signature:</h4>
<pre><code>def load_config(config_file: Optional[str] = None) -&gt; FetchNewsConfig
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>config_file</code> (Optional[str], default=None) - Path to config file</li>
</ul>

<h4>Returns:</h4> FetchNewsConfig - Loaded configuration

<h4>Behavior:</h4>
<ul>
<li>Loads from specified file or searches defaults</li>
<li>Supports YAML and JSON formats</li>
<li>Merges with environment variables</li>
<li>Caches loaded config</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.config import load_config

# Load from default locations
config = load_config()

# Load from specific file
config = load_config(&quot;custom-config.yml&quot;)

# Access configuration
print(f&quot;User agent: {config.network.user_agent}&quot;)
print(f&quot;Download images: {config.processing.download_images}&quot;)
</code></pre>

<h2>Logging API</h2>

<p>Location: Application/core/logging_config.py</p>

<h4>Import:</h4>
<pre><code>from core.logging_config import get_logger, setup_logging
</code></pre>

<h3>Functions</h3>

<h4>get_logger()</h4>

<h4>Signature:</h4>
<pre><code>def get_logger(name: str = None) -&gt; logging.Logger
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>name</code> (str, optional) - Logger name (defaults to caller&#x27;s module name)</li>
</ul>

<h4>Returns:</h4> logging.Logger - Configured logger instance

<h4>Example:</h4>
<pre><code>from core.logging_config import get_logger

# Get logger for current module
logger = get_logger(__name__)

# Use logger
logger.debug(&quot;Debug message&quot;)
logger.info(&quot;Info message&quot;)
logger.warning(&quot;Warning message&quot;)
logger.error(&quot;Error message&quot;)
logger.critical(&quot;Critical message&quot;)
</code></pre>

<h4>setup_logging()</h4>

<h4>Signature:</h4>
<pre><code>def setup_logging(
    log_level: str = &quot;INFO&quot;,
    log_file: str = None,
    use_colors: bool = True
) -&gt; None
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>log_level</code> (str, default=&quot;INFO&quot;) - Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)</li>
<li><code>log_file</code> (str, optional) - Path to log file</li>
<li><code>use_colors</code> (bool, default=True) - Enable colored console output</li>
</ul>

<h4>Behavior:</h4>
<ul>
<li>Configures root logger</li>
<li>Sets up console handler with optional colors</li>
<li>Sets up file handler if log_file specified</li>
<li>Formats with timestamps and module names</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.logging_config import setup_logging, get_logger

# Setup logging
setup_logging(
    log_level=&quot;DEBUG&quot;,
    log_file=&quot;capcat.log&quot;,
    use_colors=True
)

# Use logger
logger = get_logger(__name__)
logger.debug(&quot;Logging is configured&quot;)
</code></pre>

<h2>Utility Functions API</h2>

<p>Location: Application/core/utils.py</p>

<h4>Import:</h4>
<pre><code>from core.utils import (
    sanitize_filename,
    create_output_directory_capcat,
    resolve_url
)
</code></pre>

<h3>Functions</h3>

<h4>sanitize_filename()</h4>

<h4>Signature:</h4>
<pre><code>def sanitize_filename(filename: str, max_length: int = 100) -&gt; str
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>filename</code> (str, required) - Filename to sanitize</li>
<li><code>max_length</code> (int, default=100) - Maximum filename length</li>
</ul>

<h4>Returns:</h4> str - Sanitized filename

<h4>Behavior:</h4>
<ul>
<li>Removes invalid filesystem characters</li>
<li>Truncates to max_length</li>
<li>Preserves file extension</li>
<li>Replaces spaces with underscores</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.utils import sanitize_filename

# Sanitize filename
clean = sanitize_filename(&quot;My Article: Cool Stuff (2025).md&quot;)
print(clean)
# My_Article_Cool_Stuff_2025.md

# With length limit
short = sanitize_filename(&quot;Very Long Article Title That Exceeds Limit&quot;, max_length=20)
print(short)
# Very_Long_Article_...
</code></pre>

<h4>create_output_directory_capcat()</h4>

<h4>Signature:</h4>
<pre><code>def create_output_directory_capcat(
    base_dir: str,
    article_title: str,
    source_name: str = &quot;&quot;,
    date_str: str = None
) -&gt; str
</code></pre>

<h4>Parameters:</h4>
<ul>
<li><code>base_dir</code> (str, required) - Base output directory</li>
<li><code>article_title</code> (str, required) - Article title</li>
<li><code>source_name</code> (str, default=&quot;&quot;) - Source identifier</li>
<li><code>date_str</code> (str, optional) - Date string (auto-generated if None)</li>
</ul>

<h4>Returns:</h4> str - Created directory path

<h4>Behavior:</h4>
<ul>
<li>Creates date-based directory structure</li>
<li>Sanitizes article title for folder name</li>
<li>Creates numbered prefix for sorting</li>
<li>Returns full path to article directory</li>
</ul>

<h4>Example:</h4>
<pre><code>from core.utils import create_output_directory_capcat

output_dir = create_output_directory_capcat(
    base_dir=&quot;../News&quot;,
    article_title=&quot;Breaking News Article&quot;,
    source_name=&quot;bbc&quot;,
    date_str=&quot;25-11-2025&quot;
)

print(output_dir)
# ../News/news_25-11-2025/BBC_25-11-2025/01_Breaking_News_Article/
</code></pre>

<h2>Source Code Locations</h2>

<p>Core API modules:</p>
<ul>
<li>SourceRegistry - Application/core/source_system/source_registry.py:28</li>
<li>BaseSource - Application/core/source_system/base_source.py:78</li>
<li>SourceConfig - Application/core/source_system/base_source.py:14</li>
<li>Article - Application/core/source_system/base_source.py:59</li>
<li>ArticleFetcher - Application/core/article_fetcher.py:110</li>
<li>FetchNewsConfig - Application/core/config.py:108</li>
<li>get_logger - Application/core/logging_config.py</li>
</ul>

<h2>Related Documentation</h2>

<ul>
<li>CLI Commands: docs/tutorials/01-cli-commands-exhaustive.md</li>
<li>Source System: docs/tutorials/04-source-system-exhaustive.md</li>
<li>Configuration: docs/tutorials/03-configuration-exhaustive.md</li>
<li>Source Development: docs/tutorials/06-source-development-exhaustive.md</li>
</ul>


<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
      // Primary colors from design system (Capcat orange palette)
      primaryColor: '#FFD4B7',           // --orange-200
      primaryTextColor: '#201419',       // --ink
      primaryBorderColor: '#F1540E',     // --orange-500 / --accent-primary

      // Line and edge colors
      lineColor: '#58444c',              // --ink-medium

      // Secondary colors
      secondaryColor: '#FFEADB',         // --orange-100
      tertiaryColor: '#f9f8ed',          // --accent-cream-primary

      // Text colors
      textColor: '#201419',              // --ink
      mainBkg: '#FAF8EE',                // --cream

      // Node styling
      nodeBorder: '#F1540E',             // --accent-primary
      clusterBkg: '#faf2e7',             // --accent-cream-light
      clusterBorder: '#D44400',          // --orange-600 / --accent-hover

      // Font
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      fontSize: '16px'
    },
    flowchart: {
      nodeSpacing: 50,
      rankSpacing: 50,
      padding: 15,
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis'
    }
  });

  // Add copy buttons to Mermaid diagrams after rendering
  document.addEventListener('DOMContentLoaded', function() {
    const mermaidDivs = document.querySelectorAll('.mermaid');

    mermaidDivs.forEach(function(mermaidDiv) {
      // Get the original Mermaid source code
      const mermaidSource = mermaidDiv.textContent;

      // Create container wrapper
      const container = document.createElement('div');
      container.className = 'mermaid-container';

      // Create copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'mermaid-copy-btn';
      copyBtn.textContent = 'Copy Mermaid Code';
      copyBtn.setAttribute('title', 'Copy diagram code for Draw.io, Mermaid Live, etc.');

      copyBtn.addEventListener('click', function() {
        navigator.clipboard.writeText(mermaidSource).then(function() {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');

          setTimeout(function() {
            copyBtn.textContent = 'Copy Mermaid Code';
            copyBtn.classList.remove('copied');
          }, 2000);
        });
      });

      // Wrap the mermaid div in container and add button
      mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
      container.appendChild(mermaidDiv);
      container.appendChild(copyBtn);
    });
  });
</script>
    <script src="../../js/main.js"></script>

            </div>
        </div>
    </div>

    <!-- Footer -->
    {% include footer.html %}

    <!-- Back to Top Button -->
    <button id="backToTopBtn" title="Go to top">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
        </svg>
    </button>  </body>
