<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Reference</title>
    <link rel="stylesheet" href="../css/design-system.css">
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <!-- Header -->
    <div id="header-placeholder"></div>


    <div class="doc-container">
        <div class="container">
            <div class="doc-content">

<div class="nav-breadcrumb"><a href="index.html">Documentation Home</a></div>
<h1>API Reference</h1>

<p>Complete API documentation for Capcat&#x27;s hybrid architecture components.</p>

<h2>Core Components</h2>

<h3>SourceRegistry</h3>

<p>Central registry for source discovery and management.</p>

<pre><code>from core.source_system.source_registry import get_source_registry, SourceRegistry
</code></pre>

<h3>Class: SourceRegistry</h3>

<h5><code>__init__(sources_dir: str = None)</code></h5>
<p>Initialize the source registry.</p>

<h4>Parameters:</h4>
<ul>
<li><code>sources_dir</code> (str, optional): Path to sources directory. Defaults to <code>sources/active/</code></li>
</ul>

<h4>Example:</h4>
<pre><code>registry = SourceRegistry()
# or
registry = SourceRegistry(&quot;/custom/sources/path&quot;)
</code></pre>

<h5><code>discover_sources() -&gt; Dict[str, SourceConfig]</code></h5>
<p>Discover all available sources (config-driven and custom).</p>

<h4>Returns:</h4>
<ul>
<li><code>Dict[str, SourceConfig]</code>: Mapping of source names to configurations</li>
</ul>

<h4>Raises:</h4>
<ul>
<li><code>SourceError</code>: If source discovery fails</li>
</ul>

<h4>Example:</h4>
<pre><code>sources = registry.discover_sources()
print(f&quot;Discovered {len(sources)} sources&quot;)
for name, config in sources.items():
    print(f&quot;- {name}: {config.display_name}&quot;)
</code></pre>

<h5><code>get_source(source_name: str, session=None) -&gt; BaseSource</code></h5>
<p>Get a source instance by name.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str): Name of the source</li>
<li><code>session</code> (requests.Session, optional): HTTP session to use</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>BaseSource</code>: Source instance</li>
</ul>

<h4>Raises:</h4>
<ul>
<li><code>SourceError</code>: If source not found or cannot be instantiated</li>
</ul>

<h4>Example:</h4>
<pre><code>source = registry.get_source(&#x27;hn&#x27;)
articles = source.get_articles(count=10)
</code></pre>

<h5><code>get_available_sources() -&gt; List[str]</code></h5>
<p>Get list of available source names.</p>

<h4>Returns:</h4>
<ul>
<li><code>List[str]</code>: List of source names</li>
</ul>

<h4>Example:</h4>
<pre><code>available = registry.get_available_sources()
print(f&quot;Available sources: {&#x27;, &#x27;.join(available)}&quot;)
</code></pre>

<h5><code>validate_all_sources(deep_validation: bool = False) -&gt; Dict[str, List[str]]</code></h5>
<p>Validate all registered sources.</p>

<h4>Parameters:</h4>
<ul>
<li><code>deep_validation</code> (bool): Whether to perform network tests</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>Dict[str, List[str]]</code>: Source names mapped to validation errors</li>
</ul>

<h4>Example:</h4>
<pre><code>errors = registry.validate_all_sources(deep_validation=True)
for source, error_list in errors.items():
    if error_list:
        print(f&quot;{source}: {error_list}&quot;)
</code></pre>

<h3>Function: get_source_registry()</h3>
<p>Get the global source registry instance.</p>

<h4>Returns:</h4>
<ul>
<li><code>SourceRegistry</code>: Global registry instance</li>
</ul>

<h4>Example:</h4>
<pre><code>registry = get_source_registry()
sources = registry.get_available_sources()
</code></pre>



<h3>BaseSource</h3>

<p>Abstract base class for all source implementations.</p>

<pre><code>from core.source_system.base_source import BaseSource, SourceConfig
</code></pre>

<h3>Class: BaseSource</h3>

<h5><code>__init__(config: SourceConfig, session=None)</code></h5>
<p>Initialize the base source.</p>

<h4>Parameters:</h4>
<ul>
<li><code>config</code> (SourceConfig): Source configuration</li>
<li><code>session</code> (requests.Session, optional): HTTP session</li>
</ul>

<h4>Example:</h4>
<pre><code>class CustomSource(BaseSource):
    def __init__(self, config: SourceConfig, session=None):
        super().__init__(config, session)
</code></pre>

<h5><code>get_articles(count: int = 30) -&gt; List[Dict]</code></h5>
<h4>Abstract method</h4> - Get articles from the source.

<h4>Parameters:</h4>
<ul>
<li><code>count</code> (int): Number of articles to fetch</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>List[Dict]</code>: Articles with keys: <code>title</code>, <code>url</code>, <code>summary</code></li>
</ul>

<h4>Example Implementation:</h4>
<pre><code>def get_articles(self, count: int = 30) -&gt; List[Dict]:
    response = self.session.get(self.config.base_url)
    soup = self._get_soup(response.text)

    articles = []
    for elem in soup.select(&#x27;.article-link&#x27;):
        articles.append({
            &#x27;title&#x27;: elem.get_text(strip=True),
            &#x27;url&#x27;: self._resolve_url(elem[&#x27;href&#x27;]),
            &#x27;summary&#x27;: &#x27;&#x27;
        })

    return articles[:count]
</code></pre>

<h5><code>get_article_content(url: str) -&gt; Optional[str]</code></h5>
<p>Get full content for a specific article.</p>

<h4>Parameters:</h4>
<ul>
<li><code>url</code> (str): Article URL</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>Optional[str]</code>: Article content as HTML</li>
</ul>

<h4>Example Implementation:</h4>
<pre><code>def get_article_content(self, url: str) -&gt; Optional[str]:
    response = self.session.get(url)
    soup = self._get_soup(response.text)

    content = soup.select_one(&#x27;.article-content&#x27;)
    return str(content) if content else None
</code></pre>

<h5><code>get_comments(url: str) -&gt; List[Dict]</code></h5>
<p>Get comments for an article.</p>

<h4>Parameters:</h4>
<ul>
<li><code>url</code> (str): Article URL</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>List[Dict]</code>: Comments with keys: <code>author</code>, <code>text</code>, <code>timestamp</code></li>
</ul>

<h4>Example Implementation:</h4>
<pre><code>def get_comments(self, url: str) -&gt; List[Dict]:
    if not self.config.supports_comments:
        return []

    response = self.session.get(url)
    soup = self._get_soup(response.text)

    comments = []
    for elem in soup.select(&#x27;.comment&#x27;):
        comments.append({
            &#x27;author&#x27;: elem.select_one(&#x27;.author&#x27;).get_text(strip=True),
            &#x27;text&#x27;: elem.select_one(&#x27;.text&#x27;).get_text(strip=True),
            &#x27;timestamp&#x27;: elem.select_one(&#x27;.timestamp&#x27;).get(&#x27;datetime&#x27;)
        })

    return comments
</code></pre>

<h5><code>validate_config() -&gt; List[str]</code></h5>
<p>Validate source-specific configuration.</p>

<h4>Returns:</h4>
<ul>
<li><code>List[str]</code>: List of validation errors</li>
</ul>

<h4>Example Implementation:</h4>
<pre><code>def validate_config(self) -&gt; List[str]:
    errors = []

    if not self.config.base_url:
        errors.append(&quot;base_url is required&quot;)

    if not self.config.base_url.startswith(&#x27;https://&#x27;):
        errors.append(&quot;base_url must use HTTPS&quot;)

    return errors
</code></pre>

<h5>Utility Methods</h5>

<h6><code>_get_soup(html: str) -&gt; BeautifulSoup</code></h6>
<p>Parse HTML content.</p>

<h4>Parameters:</h4>
<ul>
<li><code>html</code> (str): HTML content</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>BeautifulSoup</code>: Parsed HTML</li>
</ul>

<h6><code>_resolve_url(url: str) -&gt; str</code></h6>
<p>Resolve relative URLs to absolute URLs.</p>

<h4>Parameters:</h4>
<ul>
<li><code>url</code> (str): Relative or absolute URL</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Absolute URL</li>
</ul>

<h6><code>_clean_text(text: str) -&gt; str</code></h6>
<p>Clean and normalize text content.</p>

<h4>Parameters:</h4>
<ul>
<li><code>text</code> (str): Raw text</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Cleaned text</li>
</ul>



<h3>SourceConfig</h3>

<p>Configuration data class for sources.</p>

<pre><code>from core.source_system.base_source import SourceConfig
</code></pre>

<h3>Class: SourceConfig</h3>

<h5><code>__init__(...)</code></h5>
<p>Initialize source configuration.</p>

<h4>Parameters:</h4>
<ul>
<li><code>name</code> (str): Source name</li>
<li><code>display_name</code> (str): Human-readable display name</li>
<li><code>base_url</code> (str): Base URL for the source</li>
<li><code>timeout</code> (float): Request timeout in seconds</li>
<li><code>rate_limit</code> (float): Minimum seconds between requests</li>
<li><code>supports_comments</code> (bool): Whether source supports comments</li>
<li><code>category</code> (str): Source category</li>
<li><code>custom_config</code> (Dict): Additional configuration</li>
</ul>

<h4>Example:</h4>
<pre><code>config = SourceConfig(
    name=&quot;example&quot;,
    display_name=&quot;Example News&quot;,
    base_url=&quot;https://example.com/&quot;,
    timeout=10.0,
    rate_limit=1.0,
    supports_comments=True,
    category=&quot;tech&quot;,
    custom_config={&quot;api_key&quot;: &quot;secret&quot;}
)
</code></pre>



<h3>PerformanceMonitor</h3>

<p>Performance monitoring and metrics collection.</p>

<pre><code>from core.source_system.performance_monitor import PerformanceMonitor, get_performance_monitor
</code></pre>

<h3>Class: PerformanceMonitor</h3>

<h5><code>record_request(source_name: str, success: bool, response_time: float)</code></h5>
<p>Record a request for performance tracking.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str): Name of the source</li>
<li><code>success</code> (bool): Whether request was successful</li>
<li><code>response_time</code> (float): Response time in seconds</li>
</ul>

<h4>Example:</h4>
<pre><code>monitor = get_performance_monitor()
monitor.record_request(&#x27;hn&#x27;, True, 2.5)
</code></pre>

<h5><code>get_source_metrics(source_name: str) -&gt; SourceMetrics</code></h5>
<p>Get performance metrics for a source.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str): Name of the source</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>SourceMetrics</code>: Performance metrics</li>
</ul>

<h4>Example:</h4>
<pre><code>metrics = monitor.get_source_metrics(&#x27;hn&#x27;)
print(f&quot;Success rate: {metrics.success_rate:.1f}%&quot;)
print(f&quot;Avg response time: {metrics.avg_response_time:.2f}s&quot;)
</code></pre>

<h5><code>get_all_metrics() -&gt; Dict[str, SourceMetrics]</code></h5>
<p>Get metrics for all sources.</p>

<h4>Returns:</h4>
<ul>
<li><code>Dict[str, SourceMetrics]</code>: All source metrics</li>
</ul>

<h4>Example:</h4>
<pre><code>all_metrics = monitor.get_all_metrics()
for source, metrics in all_metrics.items():
    print(f&quot;{source}: {metrics.success_rate:.1f}% success&quot;)
</code></pre>

<h5><code>generate_performance_report() -&gt; str</code></h5>
<p>Generate human-readable performance report.</p>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Performance report</li>
</ul>

<h4>Example:</h4>
<pre><code>report = monitor.generate_performance_report()
print(report)
</code></pre>

<h3>Function: get_performance_monitor()</h3>
<p>Get the global performance monitor instance.</p>

<h4>Returns:</h4>
<ul>
<li><code>PerformanceMonitor</code>: Global monitor instance</li>
</ul>



<h3>ValidationEngine</h3>

<p>Configuration validation and quality assurance.</p>

<pre><code>from core.source_system.validation_engine import ValidationEngine, ValidationResult
</code></pre>

<h3>Class: ValidationEngine</h3>

<h5><code>validate_source_config(config: SourceConfig) -&gt; List[ValidationResult]</code></h5>
<p>Validate a single source configuration.</p>

<h4>Parameters:</h4>
<ul>
<li><code>config</code> (SourceConfig): Source configuration</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>List[ValidationResult]</code>: Validation results</li>
</ul>

<h4>Example:</h4>
<pre><code>engine = ValidationEngine()
results = engine.validate_source_config(config)
for result in results:
    if not result.is_valid:
        print(f&quot;Error: {result.message}&quot;)
</code></pre>

<h5><code>validate_all_sources(configs: Dict[str, SourceConfig], deep_validation: bool = False)</code></h5>
<p>Validate all source configurations.</p>

<h4>Parameters:</h4>
<ul>
<li><code>configs</code> (Dict[str, SourceConfig]): Source configurations</li>
<li><code>deep_validation</code> (bool): Whether to perform network tests</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>Dict[str, List[ValidationResult]]</code>: Validation results by source</li>
</ul>

<h4>Example:</h4>
<pre><code>results = engine.validate_all_sources(configs, deep_validation=True)
</code></pre>

<h5><code>generate_validation_report(results: Dict) -&gt; str</code></h5>
<p>Generate comprehensive validation report.</p>

<h4>Parameters:</h4>
<ul>
<li><code>results</code> (Dict): Validation results from validate_all_sources</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Markdown validation report</li>
</ul>

<h4>Example:</h4>
<pre><code>report = engine.generate_validation_report(results)
with open(&#x27;validation_report.md&#x27;, &#x27;w&#x27;) as f:
    f.write(report)
</code></pre>

<h3>Class: ValidationResult</h3>

<h5>Properties</h5>
<ul>
<li><code>is_valid</code> (bool): Whether validation passed</li>
<li><code>message</code> (str): Validation message</li>
<li><code>severity</code> (str): Severity level (&quot;error&quot;, &quot;warning&quot;, &quot;info&quot;)</li>
<li><code>category</code> (str): Category (&quot;network&quot;, &quot;config&quot;, &quot;selectors&quot;, &quot;general&quot;)</li>
</ul>

<h4>Example:</h4>
<pre><code>result = ValidationResult(
    is_valid=False,
    message=&quot;Invalid CSS selector&quot;,
    severity=&quot;error&quot;,
    category=&quot;selectors&quot;
)
</code></pre>



<h3>SessionPool</h3>

<p>Global session management for optimal performance.</p>

<pre><code>from core.session_pool import get_global_session, SessionPool
</code></pre>

<h3>Function: get_global_session()</h3>
<p>Get the global HTTP session instance.</p>

<h4>Returns:</h4>
<ul>
<li><code>requests.Session</code>: Optimized session with connection pooling</li>
</ul>

<h4>Example:</h4>
<pre><code>session = get_global_session()
response = session.get(&#x27;https://example.com/&#x27;)
</code></pre>

<h3>Class: SessionPool</h3>

<h5><code>get_session() -&gt; requests.Session</code></h5>
<p>Get a configured session instance.</p>

<h4>Returns:</h4>
<ul>
<li><code>requests.Session</code>: Configured session</li>
</ul>

<h4>Example:</h4>
<pre><code>pool = SessionPool()
session = pool.get_session()
</code></pre>



<h2>Article Processing</h2>

<h3>ArticleFetcher</h3>

<p>Core article content fetching with separated concerns.</p>

<pre><code>from core.article_fetcher import ArticleFetcher
</code></pre>

<h3>Class: ArticleFetcher</h3>

<h5><code>fetch_article_content(title: str, url: str, index: int, base_folder: str, progress_callback=None) -&gt; Tuple[bool, Optional[str], Optional[str]]</code></h5>
<p>Fetch and save article content in markdown format.</p>

<h4>Note:</h4> This method handles ONLY article content. Comments should be fetched separately using source-specific methods.

<h4>Parameters:</h4>
<ul>
<li><code>title</code> (str): Article title</li>
<li><code>url</code> (str): Article URL</li>
<li><code>index</code> (int): Article index number</li>
<li><code>base_folder</code> (str): Base directory to save to</li>
<li><code>progress_callback</code> (Optional[Callable]): Progress update callback</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>Tuple[bool, Optional[str], Optional[str]]</code>: (success, article_folder_path, article_title)</li>
</ul>

<h4>Example:</h4>
<pre><code>fetcher = ArticleFetcher()
success, folder_path, title = fetcher.fetch_article_content(
    title=&quot;Example Article&quot;,
    url=&quot;https://example.com/article&quot;,
    index=1,
    base_folder=&quot;/path/to/articles&quot;
)

if success:
    print(f&quot;Article saved to: {folder_path}&quot;)
</code></pre>

<h5>Fallback Image Detection System</h5>

<h4>Automatic Activation</h4> When primary image extraction finds &lt; 2 images, the fallback system automatically:

<ol>
<li><h4>Full Page Scanning</h4> Analyzes entire original HTML before article filtering</li>
<li><h4>Intelligent UI Filtering</h4> Removes logos, icons, ads, navigation elements, tracking pixels</li>
<li><h4>Size Filtering</h4> Skips images &lt; 150px dimensions</li>
<li><h4>Duplicate Prevention</h4> Avoids re-downloading existing images</li>
<li><h4>Seamless Integration</h4> Adds as &quot;Additional Images&quot; section in markdown</li>
</ol>

<h4>Filtering Patterns:</h4>
<ul>
<li><h4>Class patterns</h4> logo, icon, avatar, nav, menu, ad, banner, social, share</li>
<li><h4>ID patterns</h4> logo, icon, nav, header, footer, sidebar</li>
<li><h4>Alt text patterns</h4> logo, icon, advertisement, navigation, social</li>
<li><h4>URL patterns</h4> logo, icon, avatar, ad, pixel, tracker, beacon, analytics</li>
</ul>

<h4>Example Output:</h4>
<pre><code># Article Title

Original article content...

## Additional Images

*The following images were found using comprehensive page scanning:*

![Fallback Image 1](images/content-image1.jpg)

![Fallback Image 2](images/content-image2.png)
</code></pre>



<h2>Unified Media Processing</h2>

<h3>UnifiedMediaProcessor</h3>

<p>Central interface for unified media processing across all sources.</p>

<pre><code>from core.unified_media_processor import UnifiedMediaProcessor
</code></pre>

<h3>Class: UnifiedMediaProcessor</h3>

<h5><code>process_article_media(content: str, html_content: str, url: str, article_folder: str, source_name: str, session: requests.Session) -&gt; str</code></h5>

<p>Process all media embedding for an article using the unified system.</p>

<h4>Parameters:</h4>
<ul>
<li><code>content</code> (str): Markdown content of the article</li>
<li><code>html_content</code> (str): Original HTML content</li>
<li><code>url</code> (str): Source URL of the article</li>
<li><code>article_folder</code> (str): Path to article folder</li>
<li><code>source_name</code> (str): Name of the news source (for configuration)</li>
<li><code>session</code> (requests.Session): HTTP session for downloading</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Updated markdown content with local image references</li>
</ul>

<h4>Example:</h4>
<pre><code>updated_content = UnifiedMediaProcessor.process_article_media(
    content=markdown_content,
    html_content=html_content,
    url=article_url,
    article_folder=article_folder,
    source_name=&quot;futurism&quot;,
    session=session
)
</code></pre>

<h5><code>add_media_config_to_source(source_config_path: str, source_name: str) -&gt; None</code></h5>

<p>Add media processing configuration to a source&#x27;s config file.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_config_path</code> (str): Path to source&#x27;s config.yaml file</li>
<li><code>source_name</code> (str): Name of the source</li>
</ul>

<h5><code>get_integration_code_example(source_name: str) -&gt; str</code></h5>

<p>Get example code for integrating unified media processing into a source.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str): Name of the source</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Example Python code for integration</li>
</ul>

<h3>MediaEmbeddingProcessor</h3>

<p>Core engine for media extraction, downloading, and URL replacement.</p>

<pre><code>from core.media_embedding_processor import MediaEmbeddingProcessor
</code></pre>

<h3>Class: MediaEmbeddingProcessor</h3>

<h5><code>__init__(source_config: Dict[str, Any], session: requests.Session)</code></h5>

<p>Initialize media processor with source-specific configuration.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_config</code> (Dict[str, Any]): Source-specific media processing configuration</li>
<li><code>session</code> (requests.Session): HTTP session for downloading</li>
</ul>

<h5><code>process_media_embedding(content: str, soup: BeautifulSoup, article_folder: str, base_url: str) -&gt; str</code></h5>

<p>Main method to process all media embedding.</p>

<h4>Parameters:</h4>
<ul>
<li><code>content</code> (str): Markdown content</li>
<li><code>soup</code> (BeautifulSoup): BeautifulSoup object of original HTML</li>
<li><code>article_folder</code> (str): Path to article folder</li>
<li><code>base_url</code> (str): Base URL of the source</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>str</code>: Updated markdown content with local image references</li>
</ul>

<h3>MediaConfigManager</h3>

<p>Manages media processing configurations for different news sources.</p>

<pre><code>from core.media_config import MediaConfigManager
</code></pre>

<h3>Class: MediaConfigManager</h3>

<h5><code>get_source_config(source_name: str) -&gt; Dict[str, Any]</code></h5>

<p>Get media processing configuration for a specific source.</p>

<h4>Parameters:</h4>
<ul>
<li><code>source_name</code> (str): Name of the news source</li>
</ul>

<h4>Returns:</h4>
<ul>
<li><code>Dict[str, Any]</code>: Dictionary with media processing configuration</li>
</ul>

<h4>Example:</h4>
<pre><code>config = MediaConfigManager.get_source_config(&#x27;futurism&#x27;)
# Returns:
# {
#     &#x27;media_processing&#x27;: {
#         &#x27;hero_image_selectors&#x27;: [&#x27;.featured-image img&#x27;, &#x27;.post-thumbnail img&#x27;],
#         &#x27;url_patterns&#x27;: {&#x27;wordpress&#x27;: [&#x27;/wp-content/uploads/&#x27;]},
#         &#x27;quality_thresholds&#x27;: {&#x27;min_width&#x27;: 150, &#x27;min_height&#x27;: 150}
#     }
# }
</code></pre>

<h5><code>get_all_source_names() -&gt; List[str]</code></h5>

<p>Get list of all configured source names.</p>

<h4>Returns:</h4>
<ul>
<li><code>List[str]</code>: List of configured source names</li>
</ul>

<h4>Supported Sources:</h4>
<ul>
<li>futurism, gizmodo, ieee, hn, bbc, cnn, nature</li>
</ul>

<h2>Comment Processing</h2>

<h3>Source-Specific Comment Fetching</h3>

<p>Comments are fetched independently from articles using source-specific methods.</p>

<h3>Hacker News Comments</h3>

<pre><code># Article and comments are fetched separately
source = registry.get_source(&#x27;hn&#x27;)

# 1. Fetch article content
success, folder_path, title = source.fetch_article_content(
    title=article.title,
    url=article.url,
    index=0,
    base_folder=output_dir
)

# 2. Fetch comments separately if article was successful
if success and article.comment_url:
    source.fetch_comments(
        comment_url=article.comment_url,
        article_title=title,
        article_folder_path=folder_path
    )
</code></pre>

<h3>Lobsters Comments</h3>

<pre><code># Similar pattern for Lobsters
source = registry.get_source(&#x27;lb&#x27;)

# Article fetching
success, folder_path, title = source.fetch_article_content(...)

# Independent comment fetching
if success and comment_url:
    source.fetch_comments(comment_url, title, folder_path)
</code></pre>

<h3>Benefits of Separated Workflows</h3>

<ol>
<li><h4>Clean Signatures</h4> Article methods don&#x27;t have comment parameters</li>
<li><h4>Independent Processing</h4> Comments can fail without losing articles</li>
<li><h4>Better Error Handling</h4> Isolated error domains</li>
<li><h4>Source Flexibility</h4> Each source handles comments differently</li>
<li><h4>Maintainability</h4> Clear separation of concerns</li>
</ol>

<h4>Error Isolation Example:</h4>
<pre><code>try:
    # Article fetching
    success, folder, title = fetcher.fetch_article_content(...)

    # Comment fetching (independent)
    if success and comment_url:
        try:
            source.fetch_comments(comment_url, title, folder)
        except Exception as e:
            logger.debug(f&quot;Comments failed: {e}&quot;)
            # Article is still saved successfully

except Exception as e:
    logger.error(f&quot;Article fetch failed: {e}&quot;)
</code></pre>



<h2>Configuration Classes</h2>

<h3>NetworkConfig</h3>

<p>Network-related configuration.</p>

<pre><code>from core.config import NetworkConfig

config = NetworkConfig(
    connect_timeout=10,
    read_timeout=8,
    user_agent=&quot;Custom User Agent&quot;
)
</code></pre>

<h3>ProcessingConfig</h3>

<p>Processing-related configuration.</p>

<pre><code>from core.config import ProcessingConfig

config = ProcessingConfig(
    max_workers=8,
    download_images=True,
    download_videos=False
)
</code></pre>

<h2>Data Classes</h2>

<h3>SourceMetrics</h3>

<p>Performance metrics data class.</p>

<pre><code>from core.source_system.performance_monitor import SourceMetrics

@dataclass
class SourceMetrics:
    source_name: str
    source_type: str
    total_requests: int = 0
    successful_requests: int = 0
    avg_response_time: float = 0.0
    articles_discovered: int = 0
    articles_fetched: int = 0
    articles_failed: int = 0
    last_error: Optional[str] = None

    @property
    def success_rate(self) -&gt; float:
        return (self.successful_requests / self.total_requests) * 100
</code></pre>

<h2>Exception Classes</h2>

<h3>SourceError</h3>

<p>Base exception for source-related errors.</p>

<pre><code>from core.source_system.base_source import SourceError

try:
    source = registry.get_source(&#x27;nonexistent&#x27;)
except SourceError as e:
    print(f&quot;Source error: {e}&quot;)
</code></pre>

<h3>ConfigurationError</h3>

<p>Configuration-related errors.</p>

<pre><code>from core.source_system.base_source import ConfigurationError

try:
    config = load_invalid_config()
except ConfigurationError as e:
    print(f&quot;Configuration error: {e}&quot;)
</code></pre>

<h2>Usage Examples</h2>

<h3>Complete Source Implementation</h3>
<pre><code>from typing import List, Dict, Optional
from core.source_system.base_source import BaseSource, SourceConfig

class ExampleSource(BaseSource):
    def get_articles(self, count: int = 30) -&gt; List[Dict]:
        response = self.session.get(self.config.base_url)
        response.raise_for_status()

        soup = self._get_soup(response.text)
        articles = []

        for link in soup.select(&#x27;.article-link&#x27;)[:count]:
            articles.append({
                &#x27;title&#x27;: self._clean_text(link.get_text()),
                &#x27;url&#x27;: self._resolve_url(link[&#x27;href&#x27;]),
                &#x27;summary&#x27;: &#x27;&#x27;
            })

        return articles

    def get_article_content(self, url: str) -&gt; Optional[str]:
        response = self.session.get(url)
        soup = self._get_soup(response.text)

        content = soup.select_one(&#x27;.article-content&#x27;)
        return str(content) if content else None

    def validate_config(self) -&gt; List[str]:
        errors = []
        if not self.config.base_url:
            errors.append(&quot;base_url is required&quot;)
        return errors
</code></pre>

<h3>Registry Usage</h3>
<pre><code># Get registry and discover sources
registry = get_source_registry()
available = registry.get_available_sources()

# Create source instance
source = registry.get_source(&#x27;hn&#x27;)

# Fetch articles
articles = source.get_articles(count=10)

# Get performance metrics
monitor = get_performance_monitor()
metrics = monitor.get_source_metrics(&#x27;hn&#x27;)
</code></pre>



<em>This API reference covers all public interfaces in the Capcat hybrid architecture. For implementation examples, see the Source Development Guide.</em>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
      // Primary colors from design system (Capcat orange palette)
      primaryColor: '#FFD4B7',           // --orange-200
      primaryTextColor: '#201419',       // --ink
      primaryBorderColor: '#F1540E',     // --orange-500 / --accent-primary

      // Line and edge colors
      lineColor: '#58444c',              // --ink-medium

      // Secondary colors
      secondaryColor: '#FFEADB',         // --orange-100
      tertiaryColor: '#f9f8ed',          // --accent-cream-primary

      // Text colors
      textColor: '#201419',              // --ink
      mainBkg: '#FAF8EE',                // --cream

      // Node styling
      nodeBorder: '#F1540E',             // --accent-primary
      clusterBkg: '#faf2e7',             // --accent-cream-light
      clusterBorder: '#D44400',          // --orange-600 / --accent-hover

      // Font
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      fontSize: '16px'
    },
    flowchart: {
      nodeSpacing: 50,
      rankSpacing: 50,
      padding: 15,
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis'
    }
  });

  // Add copy buttons to Mermaid diagrams after rendering
  document.addEventListener('DOMContentLoaded', function() {
    const mermaidDivs = document.querySelectorAll('.mermaid');

    mermaidDivs.forEach(function(mermaidDiv) {
      // Get the original Mermaid source code
      const mermaidSource = mermaidDiv.textContent;

      // Create container wrapper
      const container = document.createElement('div');
      container.className = 'mermaid-container';

      // Create copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'mermaid-copy-btn';
      copyBtn.textContent = 'Copy Mermaid Code';
      copyBtn.setAttribute('title', 'Copy diagram code for Draw.io, Mermaid Live, etc.');

      copyBtn.addEventListener('click', function() {
        navigator.clipboard.writeText(mermaidSource).then(function() {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');

          setTimeout(function() {
            copyBtn.textContent = 'Copy Mermaid Code';
            copyBtn.classList.remove('copied');
          }, 2000);
        });
      });

      // Wrap the mermaid div in container and add button
      mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
      container.appendChild(mermaidDiv);
      container.appendChild(copyBtn);
    });
  });
</script>
    <script src="../js/main.js"></script>

            
<nav class="chapter-navigation" aria-label="Chapter navigation">
    <div class="next-chapter-content">
        <span class="next-chapter-label">Next Chapter</span>
        <span class="next-chapter-arrow" aria-hidden="true">â†’</span>
        <a href="testing.html" class="next-chapter-link" rel="next">Testing Guide</a>
    </div>
</nav>
</div>
        </div>
    </div>

    <!-- Footer -->
    <div id="footer-placeholder"></div>

    <!-- Back to Top Button -->
    <button id="backToTopBtn" title="Go to top">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
        </svg>
    </button>

    <script src="../../js/includes-loader.js"></script>
  </body>
