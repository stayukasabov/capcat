<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Source System Comprehensive Reference</title>
    <link rel="stylesheet" href="../../css/design-system.css">
    <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
    <!-- Header -->
    {% include header.html %}


    <div class="doc-container">
        <div class="container">
            <div class="doc-content">

<div class="nav-breadcrumb"><a href="../index.html">Documentation Home</a> / tutorials</div>
<h1>Source System Comprehensive Reference</h1>

<p>Complete documentation of EVERY source system component, class, method, and operation in Capcat.</p>

<p>Source: Application/core/source_system/</p>

<h2>Architecture Overview</h2>

<p>The source system implements a hybrid architecture supporting both config-driven (YAML) and custom (Python) sources with automatic discovery, validation, and management.</p>

<h3>Directory Structure</h3>

<div class="ascii-art">Application/
└── core/
    └── source_system/
        ├── base_source.py              # Abstract base classes
        ├── source_registry.py          # Source discovery and management
        ├── source_factory.py           # Source instantiation
        ├── validation_engine.py        # Configuration validation
        ├── performance_monitor.py      # Performance tracking
        ├── config_driven_source.py     # Config-driven implementation
        └── ...                         # Additional components

sources/
└── active/
    ├── config_driven/
    │   └── configs/
    │       ├── iq.yaml
    │       ├── ieee.yaml
    │       └── ...
    └── custom/
        ├── hn/
        │   ├── source.py
        │   └── config.yaml
        ├── bbc/
        │   ├── source.py
        │   └── config.yaml
        └── ...
</div>

<h2>Core Data Classes</h2>

<h3>SourceConfig</h3>
<p>Location: Application/core/source_system/base_source.py:14</p>

<h4>Purpose:</h4> Configuration data class for news sources.

<h4>Complete Field List:</h4>

<ul>
<li><h4>name</h4> → str</li>
<li><h4>display_name</h4> → str</li>
<li><h4>base_url</h4> → str</li>
<li><h4>timeout</h4> → float</li>
<li><h4>rate_limit</h4> → float</li>
<li><h4>supports_comments</h4> → bool</li>
<li><h4>has_comments</h4> → bool</li>
<li><h4>category</h4> → str</li>
<li><h4>custom_config</h4> → Dict[str, Any]</li>
</ul>

<h4>Methods:</h4>

<h3>__post_init__()</h3>
<pre><code>def __post_init__(self):
    &quot;&quot;&quot;Initialize custom_config as empty dict if None.&quot;&quot;&quot;
    if self.custom_config is None:
        self.custom_config = {}
</code></pre>

<h3>to_dict() -&gt; Dict[str, Any]</h3>
<p>Location: Application/core/source_system/base_source.py:34</p>

<pre><code>def to_dict(self) -&gt; Dict[str, Any]:
    &quot;&quot;&quot;
    Convert to dictionary format for compatibility.

    Returns:
        Dictionary representation of the source configuration
    &quot;&quot;&quot;
    result = {
        &quot;name&quot;: self.name,
        &quot;display_name&quot;: self.display_name,
        &quot;base_url&quot;: self.base_url,
        &quot;timeout&quot;: self.timeout,
        &quot;rate_limit&quot;: self.rate_limit,
        &quot;supports_comments&quot;: self.supports_comments,
        &quot;has_comments&quot;: self.has_comments,
        &quot;category&quot;: self.category,
    }

    # Add custom configuration
    if self.custom_config:
        result.update(self.custom_config)

    return result
</code></pre>

<h4>Usage:</h4>
<pre><code>from core.source_system.base_source import SourceConfig

config = SourceConfig(
    name=&quot;example&quot;,
    display_name=&quot;Example News&quot;,
    base_url=&quot;https://example.com/&quot;,
    timeout=15.0,
    rate_limit=2.0,
    supports_comments=True,
    category=&quot;tech&quot;,
    custom_config={&quot;api_key&quot;: &quot;secret&quot;}
)

# Convert to dictionary
config_dict = config.to_dict()
</code></pre>

<h3>Article</h3>
<p>Location: Application/core/source_system/base_source.py:59</p>

<h4>Purpose:</h4> Data class representing a news article.

<h4>Complete Field List:</h4>

<ul>
<li><h4>title</h4> → str</li>
<li><h4>url</h4> → str</li>
<li><h4>comment_url</h4> → Optional[str]</li>
<li><h4>author</h4> → Optional[str]</li>
<li><h4>published_date</h4> → Optional[str]</li>
<li><h4>summary</h4> → Optional[str]</li>
<li><h4>tags</h4> → List[str]</li>
</ul>

<h4>Methods:</h4>

<h3>__post_init__()</h3>
<pre><code>def __post_init__(self):
    &quot;&quot;&quot;Initialize tags as empty list if None.&quot;&quot;&quot;
    if self.tags is None:
        self.tags = []
</code></pre>

<h4>Usage:</h4>
<pre><code>from core.source_system.base_source import Article

article = Article(
    title=&quot;Example Article&quot;,
    url=&quot;https://example.com/article/123&quot;,
    comment_url=&quot;https://example.com/article/123/comments&quot;,
    author=&quot;John Doe&quot;,
    published_date=&quot;2025-11-25&quot;,
    summary=&quot;This is an example article.&quot;,
    tags=[&quot;tech&quot;, &quot;ai&quot;, &quot;news&quot;]
)
</code></pre>

<h2>Abstract Base Class</h2>

<h3>BaseSource</h3>
<p>Location: Application/core/source_system/base_source.py:78</p>

<h4>Purpose:</h4> Abstract base class for all news sources defining the contract all implementations must follow.

<h4>Constructor:</h4>

<h3>__init__(config: SourceConfig, session: Optional[requests.Session] = None)</h3>
<p>Location: Application/core/source_system/base_source.py:86</p>

<pre><code>def __init__(
    self, config: SourceConfig, session: Optional[requests.Session] = None
):
    &quot;&quot;&quot;
    Initialize the source with configuration.

    Args:
        config: Source configuration
        session: Optional HTTP session for connection pooling
    &quot;&quot;&quot;
    self.config = config
    self.session = session or requests.Session()
    self.logger = self._get_logger()

    # Initialize performance monitoring
    self._setup_performance_monitoring()
</code></pre>

<h4>Attributes:</h4>
<ul>
<li><code>self.config</code> (SourceConfig) - Source configuration</li>
<li><code>self.session</code> (requests.Session) - HTTP session for requests</li>
<li><code>self.logger</code> (logging.Logger) - Logger instance</li>
</ul>

<h4>Abstract Properties:</h4>

<h3>source_type -&gt; str</h3>
<p>Location: Application/core/source_system/base_source.py:103</p>

<pre><code>@property
@abstractmethod
def source_type(self) -&gt; str:
    &quot;&quot;&quot;Return the source type (&#x27;config_driven&#x27; or &#x27;custom&#x27;).&quot;&quot;&quot;
    pass
</code></pre>

<h4>Must return:</h4> &quot;config_driven&quot; or &quot;custom&quot;

<h4>Abstract Methods:</h4>

<h3>discover_articles(count: int) -&gt; List[Article]</h3>
<p>Location: Application/core/source_system/base_source.py:109</p>

<pre><code>@abstractmethod
def discover_articles(self, count: int) -&gt; List[Article]:
    &quot;&quot;&quot;
    Discover articles from the source.

    Args:
        count: Maximum number of articles to discover

    Returns:
        List of Article objects

    Raises:
        SourceError: If article discovery fails
    &quot;&quot;&quot;
    pass
</code></pre>

<h4>Implementation Requirements:</h4>
<ul>
<li>Fetch article listings from source</li>
<li>Parse article metadata (title, URL, optional summary)</li>
<li>Return up to <code>count</code> articles</li>
<li>Handle network errors gracefully</li>
<li>Respect rate limiting</li>
</ul>

<h4>Example Implementation:</h4>
<pre><code>def discover_articles(self, count: int) -&gt; List[Article]:
    response = self.session.get(self.config.base_url)
    soup = BeautifulSoup(response.text, &#x27;html.parser&#x27;)

    articles = []
    for link in soup.select(&#x27;.article-link&#x27;)[:count]:
        articles.append(Article(
            title=link.get_text(strip=True),
            url=self._resolve_url(link[&#x27;href&#x27;]),
            summary=&#x27;&#x27;
        ))

    return articles
</code></pre>

<h3>fetch_article_content(article: Article, output_dir: str, progress_callback=None) -&gt; Tuple[bool, Optional[str]]</h3>
<p>Location: Application/core/source_system/base_source.py:125</p>

<pre><code>@abstractmethod
def fetch_article_content(
    self, article: Article, output_dir: str, progress_callback=None
) -&gt; Tuple[bool, Optional[str]]:
    &quot;&quot;&quot;
    Fetch and save article content.

    Args:
        article: Article to fetch
        output_dir: Directory to save content
        progress_callback: Optional progress callback function

    Returns:
        Tuple of (success, article_path)

    Raises:
        SourceError: If content fetching fails
    &quot;&quot;&quot;
    pass
</code></pre>

<h4>Implementation Requirements:</h4>
<ul>
<li>Fetch article HTML content</li>
<li>Extract main article content</li>
<li>Download and process media (images, videos)</li>
<li>Convert to Markdown format</li>
<li>Save to output directory</li>
<li>Return success status and article path</li>
</ul>

<h4>Return Values:</h4>
<ul>
<li><code>(True, &quot;/path/to/article&quot;)</code> - Success</li>
<li><code>(False, None)</code> - Failure</li>
</ul>

<h4>Example Implementation:</h4>
<pre><code>def fetch_article_content(
    self, article: Article, output_dir: str, progress_callback=None
) -&gt; Tuple[bool, Optional[str]]:
    try:
        response = self.session.get(article.url)
        soup = BeautifulSoup(response.text, &#x27;html.parser&#x27;)

        content = soup.select_one(&#x27;.article-content&#x27;)
        if not content:
            return False, None

        # Process content, download media, convert to markdown
        markdown = self._convert_to_markdown(content)

        # Save to output directory
        article_path = os.path.join(output_dir, &#x27;article.md&#x27;)
        with open(article_path, &#x27;w&#x27;) as f:
            f.write(markdown)

        return True, article_path

    except Exception as e:
        self.logger.error(f&quot;Failed to fetch article: {e}&quot;)
        return False, None
</code></pre>

<h4>Concrete Methods:</h4>

<h3>fetch_comments(article: Article, output_dir: str, progress_callback=None) -&gt; bool</h3>
<p>Location: Application/core/source_system/base_source.py:145</p>

<pre><code>def fetch_comments(
    self, article: Article, output_dir: str, progress_callback=None
) -&gt; bool:
    &quot;&quot;&quot;
    Fetch and save article comments (if supported).

    Args:
        article: Article to fetch comments for
        output_dir: Directory to save comments
        progress_callback: Optional progress callback function

    Returns:
        True if comments were fetched successfully, False otherwise
    &quot;&quot;&quot;
    if not self.config.supports_comments:
        return False
    return self._fetch_comments_impl(
        article, output_dir, progress_callback
    )
</code></pre>

<h4>Behavior:</h4>
<ul>
<li>Returns <code>False</code> immediately if <code>supports_comments</code> is False</li>
<li>Delegates to <code>_fetch_comments_impl()</code> if comments supported</li>
<li>Optional method - not all sources implement comments</li>
</ul>

<h3>_fetch_comments_impl(article: Article, output_dir: str, progress_callback=None) -&gt; bool</h3>
<p>Location: Application/core/source_system/base_source.py:165</p>

<pre><code>def _fetch_comments_impl(
    self, article: Article, output_dir: str, progress_callback=None
) -&gt; bool:
    &quot;&quot;&quot;
    Implementation of comment fetching (override in subclasses that support comments).

    Args:
        article: Article to fetch comments for
        output_dir: Directory to save comments
        progress_callback: Optional progress callback function

    Returns:
        True if comments were fetched successfully, False otherwise
    &quot;&quot;&quot;
    return False
</code></pre>

<h4>Override this method</h4> in subclasses that support comments.

<h4>Example Implementation:</h4>
<pre><code>def _fetch_comments_impl(
    self, article: Article, output_dir: str, progress_callback=None
) -&gt; bool:
    if not article.comment_url:
        return False

    try:
        response = self.session.get(article.comment_url)
        soup = BeautifulSoup(response.text, &#x27;html.parser&#x27;)

        comments = []
        for comment_elem in soup.select(&#x27;.comment&#x27;):
            comments.append({
                &#x27;author&#x27;: comment_elem.select_one(&#x27;.author&#x27;).get_text(),
                &#x27;text&#x27;: comment_elem.select_one(&#x27;.text&#x27;).get_text(),
                &#x27;timestamp&#x27;: comment_elem.select_one(&#x27;.timestamp&#x27;).get(&#x27;datetime&#x27;)
            })

        # Save comments to file
        comments_path = os.path.join(output_dir, &#x27;comments.md&#x27;)
        with open(comments_path, &#x27;w&#x27;) as f:
            for comment in comments:
                f.write(f&quot;**{comment[&#x27;author&#x27;]}** - {comment[&#x27;timestamp&#x27;]}\n\n&quot;)
                f.write(f&quot;{comment[&#x27;text&#x27;]}\n\n---\n\n&quot;)

        return True

    except Exception as e:
        self.logger.error(f&quot;Failed to fetch comments: {e}&quot;)
        return False
</code></pre>

<h3>validate_config() -&gt; List[str]</h3>
<p>Location: Application/core/source_system/base_source.py:181</p>

<pre><code>def validate_config(self) -&gt; List[str]:
    &quot;&quot;&quot;
    Validate the source configuration.

    Returns:
        List of validation error messages (empty if valid)
    &quot;&quot;&quot;
    errors = []

    if not self.config.name:
        errors.append(&quot;Source name is required&quot;)

    if not self.config.display_name:
        errors.append(&quot;Source display name is required&quot;)

    if not self.config.base_url:
        errors.append(&quot;Source base URL is required&quot;)
    elif not self.config.base_url.startswith((&quot;http://&quot;, &quot;https://&quot;)):
        errors.append(
            &quot;Source base URL must start with http:// or https://&quot;
        )

    if self.config.timeout &lt;= 0:
        errors.append(&quot;Timeout must be positive&quot;)

    if self.config.rate_limit &lt; 0:
        errors.append(&quot;Rate limit cannot be negative&quot;)

    return errors
</code></pre>

<h4>Validation Checks:</h4>
<ul>
<li>Name not empty</li>
<li>Display name not empty</li>
<li>Base URL not empty</li>
<li>Base URL starts with http:// or https://</li>
<li>Timeout &gt; 0</li>
<li>Rate limit &gt;= 0</li>
</ul>

<h4>Usage:</h4>
<pre><code>source = registry.get_source(&#x27;hn&#x27;)
errors = source.validate_config()

if errors:
    print(f&quot;Configuration errors: {errors}&quot;)
else:
    print(&quot;Configuration valid&quot;)
</code></pre>

<h2>Source Registry</h2>

<h3>SourceRegistry</h3>
<p>Location: Application/core/source_system/source_registry.py:28</p>

<h4>Purpose:</h4> Registry for managing and discovering news sources. Supports auto-discovery and validation.

<h4>Constructor:</h4>

<h3>__init__(sources_dir: str = None)</h3>
<p>Location: Application/core/source_system/source_registry.py:36</p>

<pre><code>def __init__(self, sources_dir: str = None):
    &quot;&quot;&quot;
    Initialize the source registry.

    Args:
        sources_dir: Path to sources directory (defaults to sources/ relative to app root)
    &quot;&quot;&quot;
    self.logger = get_logger(__name__)
    self._sources: Dict[str, Type[BaseSource]] = {}
    self._configs: Dict[str, SourceConfig] = {}
    self._source_instances: Dict[str, BaseSource] = {}
    self.validation_engine = ValidationEngine()

    # Determine sources directory - now uses active/ subdirectory
    if sources_dir is None:
        app_root = Path(__file__).parent.parent.parent
        self.sources_dir = app_root / &quot;sources&quot; / &quot;active&quot;
    else:
        self.sources_dir = Path(sources_dir)
</code></pre>

<h4>Attributes:</h4>
<ul>
<li><code>self._sources</code> - Dictionary of source classes by name</li>
<li><code>self._configs</code> - Dictionary of source configurations by name</li>
<li><code>self._source_instances</code> - Dictionary of instantiated sources (cache)</li>
<li><code>self.validation_engine</code> - ValidationEngine instance</li>
<li><code>self.sources_dir</code> - Path to sources directory</li>
</ul>

<h4>Default sources directory:</h4> <code>Application/sources/active/</code>

<h4>Methods:</h4>

<h3>discover_sources() -&gt; Dict[str, SourceConfig]</h3>
<p>Location: Application/core/source_system/source_registry.py:60</p>

<pre><code>def discover_sources(self) -&gt; Dict[str, SourceConfig]:
    &quot;&quot;&quot;
    Discover all available sources (both config-driven and custom).

    Returns:
        Dictionary mapping source names to their configurations

    Raises:
        SourceError: If source discovery fails
    &quot;&quot;&quot;
    self.logger.debug(&quot;Starting source discovery&quot;)

    try:
        # Clear existing data
        self._sources.clear()
        self._configs.clear()
        self._source_instances.clear()

        # Discover config-driven sources
        self._discover_config_driven_sources()

        # Discover custom sources
        self._discover_custom_sources()

        self.logger.debug(
            f&quot;Source discovery completed. Found {len(self._configs)} sources&quot;
        )
        return self._configs.copy()

    except Exception as e:
        raise SourceError(f&quot;Source discovery failed: {e}&quot;)
</code></pre>

<h4>Behavior:</h4>
<ol>
<li>Clear existing source data</li>
<li>Discover config-driven sources from <code>sources/active/config_driven/configs/</code></li>
<li>Discover custom sources from <code>sources/active/custom/</code></li>
<li>Return dictionary of all discovered sources</li>
</ol>

<h4>Discovery Process:</h4>

<h4>Config-Driven Discovery:</h4>
<ol>
<li>Scan <code>sources/active/config_driven/configs/</code> for <code>.yaml</code>, <code>.yml</code>, <code>.json</code> files</li>
<li>Load each configuration file</li>
<li>Create SourceConfig from file data</li>
<li>Validate configuration</li>
<li>Register source if valid</li>
</ol>

<h4>Custom Discovery:</h4>
<ol>
<li>Scan <code>sources/active/custom/</code> for directories</li>
<li>Look for <code>source.py</code> in each directory</li>
<li>Look for <code>config.yaml</code> (or <code>.yml</code>, <code>.json</code>) in each directory</li>
<li>Load configuration</li>
<li>Import source class from <code>source.py</code></li>
<li>Register source</li>
</ol>

<h3>_discover_config_driven_sources()</h3>
<p>Location: Application/core/source_system/source_registry.py:92</p>

<pre><code>def _discover_config_driven_sources(self):
    &quot;&quot;&quot;Discover sources defined by configuration files.&quot;&quot;&quot;
    config_dir = self.sources_dir / &quot;config_driven&quot; / &quot;configs&quot;

    if not config_dir.exists():
        self.logger.debug(
            f&quot;Config-driven sources directory not found: {config_dir}&quot;
        )
        return

    self.logger.debug(
        f&quot;Discovering config-driven sources in: {config_dir}&quot;
    )

    for config_file in config_dir.iterdir():
        if config_file.suffix in {&quot;.yaml&quot;, &quot;.yml&quot;, &quot;.json&quot;}:
            try:
                config = self._load_config_file(config_file)
                source_name = config_file.stem

                # Create SourceConfig
                source_config = SourceConfig(
                    name=source_name,
                    display_name=config.get(
                        &quot;display_name&quot;, source_name.title()
                    ),
                    base_url=config[&quot;base_url&quot;],
                    timeout=config.get(&quot;timeout&quot;, 10.0),
                    rate_limit=config.get(&quot;rate_limit&quot;, 1.0),
                    supports_comments=config.get(
                        &quot;supports_comments&quot;, False
                    ),
                    category=config.get(&quot;category&quot;, &quot;general&quot;),
                    custom_config=config,
                )

                # Validate configuration
                errors = self._validate_config_driven_config(source_config)
                if errors:
                    self.logger.warning(
                        f&quot;Config validation failed for {source_name}: {errors}&quot;
                    )
                    continue

                self._configs[source_name] = source_config
                self.logger.debug(
                    f&quot;Registered config-driven source: {source_name}&quot;
                )

            except Exception as e:
                self.logger.warning(
                    f&quot;Failed to load config-driven source {config_file}: {e}&quot;
                )
</code></pre>

<h4>File Format Support:</h4>
<ul>
<li><code>.yaml</code> - YAML format</li>
<li><code>.yml</code> - YAML format</li>
<li><code>.json</code> - JSON format</li>
</ul>

<h4>Source Name:</h4> Derived from filename (stem without extension)

<h3>_discover_custom_sources()</h3>
<p>Location: Application/core/source_system/source_registry.py:146</p>

<pre><code>def _discover_custom_sources(self):
    &quot;&quot;&quot;Discover custom source implementations.&quot;&quot;&quot;
    custom_dir = self.sources_dir / &quot;custom&quot;

    if not custom_dir.exists():
        self.logger.debug(
            f&quot;Custom sources directory not found: {custom_dir}&quot;
        )
        return

    self.logger.debug(f&quot;Discovering custom sources in: {custom_dir}&quot;)

    for source_dir in custom_dir.iterdir():
        if source_dir.is_dir() and not source_dir.name.startswith(&quot;_&quot;):
            try:
                self._load_custom_source(source_dir)
            except Exception as e:
                self.logger.warning(
                    f&quot;Failed to load custom source {source_dir.name}: {e}&quot;
                )
</code></pre>

<h4>Discovery Rules:</h4>
<ul>
<li>Only directories (not files)</li>
<li>Ignore directories starting with <code>_</code></li>
<li>Each directory represents one source</li>
</ul>

<h3>get_source(source_name: str, session=None) -&gt; BaseSource</h3>
<p>Location: Application/core/source_system/source_registry.py (method continues beyond line 200)</p>

<pre><code>def get_source(self, source_name: str, session=None) -&gt; BaseSource:
    &quot;&quot;&quot;
    Get a source instance by name.

    Args:
        source_name: Name of the source
        session: Optional HTTP session to use

    Returns:
        Source instance

    Raises:
        SourceError: If source not found or cannot be instantiated
    &quot;&quot;&quot;
    # Check cache first
    if source_name in self._source_instances:
        return self._source_instances[source_name]

    # Get configuration
    if source_name not in self._configs:
        raise SourceError(f&quot;Source not found: {source_name}&quot;)

    config = self._configs[source_name]

    # Instantiate source
    source = self._instantiate_source(source_name, config, session)

    # Cache instance
    self._source_instances[source_name] = source

    return source
</code></pre>

<h4>Caching:</h4> Source instances are cached after first instantiation

<h4>Usage:</h4>
<pre><code>registry = get_source_registry()
source = registry.get_source(&#x27;hn&#x27;)
articles = source.discover_articles(count=10)
</code></pre>

<h3>get_available_sources() -&gt; List[str]</h3>
<pre><code>def get_available_sources(self) -&gt; List[str]:
    &quot;&quot;&quot;
    Get list of available source names.

    Returns:
        List of source names
    &quot;&quot;&quot;
    if not self._configs:
        self.discover_sources()
    return list(self._configs.keys())
</code></pre>

<h4>Usage:</h4>
<pre><code>registry = get_source_registry()
sources = registry.get_available_sources()
print(f&quot;Available sources: {&#x27;, &#x27;.join(sources)}&quot;)
</code></pre>

<h3>get_source_config(source_name: str) -&gt; Optional[SourceConfig]</h3>
<pre><code>def get_source_config(self, source_name: str) -&gt; Optional[SourceConfig]:
    &quot;&quot;&quot;
    Get source configuration by name.

    Args:
        source_name: Name of the source

    Returns:
        Source configuration or None if not found
    &quot;&quot;&quot;
    if not self._configs:
        self.discover_sources()
    return self._configs.get(source_name)
</code></pre>

<h4>Usage:</h4>
<pre><code>registry = get_source_registry()
config = registry.get_source_config(&#x27;hn&#x27;)
print(f&quot;Base URL: {config.base_url}&quot;)
print(f&quot;Category: {config.category}&quot;)
</code></pre>

<h3>get_sources_by_category(category: str) -&gt; List[str]</h3>
<pre><code>def get_sources_by_category(self, category: str) -&gt; List[str]:
    &quot;&quot;&quot;
    Get sources by category.

    Args:
        category: Category name (tech, news, science, etc.)

    Returns:
        List of source names in category
    &quot;&quot;&quot;
    if not self._configs:
        self.discover_sources()

    return [
        name for name, config in self._configs.items()
        if config.category == category
    ]
</code></pre>

<h4>Usage:</h4>
<pre><code>registry = get_source_registry()
tech_sources = registry.get_sources_by_category(&#x27;tech&#x27;)
print(f&quot;Tech sources: {&#x27;, &#x27;.join(tech_sources)}&quot;)
</code></pre>

<h3>validate_all_sources(deep_validation: bool = False) -&gt; Dict[str, List[str]]</h3>
<pre><code>def validate_all_sources(self, deep_validation: bool = False) -&gt; Dict[str, List[str]]:
    &quot;&quot;&quot;
    Validate all registered sources.

    Args:
        deep_validation: Whether to perform network tests

    Returns:
        Dictionary mapping source names to validation errors
    &quot;&quot;&quot;
    if not self._configs:
        self.discover_sources()

    errors = {}
    for source_name, config in self._configs.items():
        source_errors = []

        # Basic validation
        if not config.name:
            source_errors.append(&quot;Missing source name&quot;)
        if not config.base_url:
            source_errors.append(&quot;Missing base URL&quot;)

        # Deep validation (network tests)
        if deep_validation:
            try:
                source = self.get_source(source_name)
                test_articles = source.discover_articles(count=1)
                if not test_articles:
                    source_errors.append(&quot;Failed to discover any articles&quot;)
            except Exception as e:
                source_errors.append(f&quot;Network test failed: {e}&quot;)

        if source_errors:
            errors[source_name] = source_errors

    return errors
</code></pre>

<h4>Validation Types:</h4>
<ul>
<li><h4>Basic:</h4> Configuration field validation</li>
<li><h4>Deep:</h4> Network connectivity and article discovery tests</li>
</ul>

<h4>Usage:</h4>
<pre><code>registry = get_source_registry()

# Basic validation
errors = registry.validate_all_sources(deep_validation=False)

# Deep validation (with network tests)
errors = registry.validate_all_sources(deep_validation=True)

for source, error_list in errors.items():
    if error_list:
        print(f&quot;{source}: {&#x27;, &#x27;.join(error_list)}&quot;)
</code></pre>

<h3>Global Registry Functions</h3>

<h3>get_source_registry() -&gt; SourceRegistry</h3>
<pre><code>_registry_instance = None

def get_source_registry() -&gt; SourceRegistry:
    &quot;&quot;&quot;Get the global source registry instance.&quot;&quot;&quot;
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = SourceRegistry()
        _registry_instance.discover_sources()
    return _registry_instance
</code></pre>

<h4>Usage:</h4>
<pre><code>from core.source_system.source_registry import get_source_registry

registry = get_source_registry()
sources = registry.get_available_sources()
</code></pre>

<h2>Exception Classes</h2>

<h3>SourceError</h3>
<p>Location: Application/core/source_system/base_source.py</p>

<pre><code>class SourceError(Exception):
    &quot;&quot;&quot;Base exception for source-related errors.&quot;&quot;&quot;
    pass
</code></pre>

<h4>Usage:</h4>
<pre><code>from core.source_system.base_source import SourceError

try:
    source = registry.get_source(&#x27;nonexistent&#x27;)
except SourceError as e:
    print(f&quot;Source error: {e}&quot;)
</code></pre>

<h3>ConfigurationError</h3>
<p>Location: Application/core/source_system/base_source.py</p>

<pre><code>class ConfigurationError(SourceError):
    &quot;&quot;&quot;Configuration-related errors.&quot;&quot;&quot;
    pass
</code></pre>

<h4>Usage:</h4>
<pre><code>from core.source_system.base_source import ConfigurationError

try:
    config = load_invalid_config()
except ConfigurationError as e:
    print(f&quot;Configuration error: {e}&quot;)
</code></pre>

<h2>Source Code Locations</h2>

<p>Core classes:</p>
<ul>
<li><code>SourceConfig</code> - Application/core/source_system/base_source.py:14</li>
<li><code>Article</code> - Application/core/source_system/base_source.py:59</li>
<li><code>BaseSource</code> - Application/core/source_system/base_source.py:78</li>
<li><code>SourceRegistry</code> - Application/core/source_system/source_registry.py:28</li>
</ul>

<p>Global functions:</p>
<ul>
<li><code>get_source_registry()</code> - Application/core/source_system/source_registry.py</li>
</ul>

<p>Exception classes:</p>
<ul>
<li><code>SourceError</code> - Application/core/source_system/base_source.py</li>
<li><code>ConfigurationError</code> - Application/core/source_system/base_source.py</li>
</ul>

<h2>Related Documentation</h2>

<ul>
<li>API Functions: docs/tutorials/05-api-functions-exhaustive.md</li>
<li>Source Development: docs/tutorials/06-source-development-exhaustive.md</li>
<li>Configuration: docs/tutorials/03-configuration-exhaustive.md</li>
</ul>


<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
      // Primary colors from design system (Capcat orange palette)
      primaryColor: '#FFD4B7',           // --orange-200
      primaryTextColor: '#201419',       // --ink
      primaryBorderColor: '#F1540E',     // --orange-500 / --accent-primary

      // Line and edge colors
      lineColor: '#58444c',              // --ink-medium

      // Secondary colors
      secondaryColor: '#FFEADB',         // --orange-100
      tertiaryColor: '#f9f8ed',          // --accent-cream-primary

      // Text colors
      textColor: '#201419',              // --ink
      mainBkg: '#FAF8EE',                // --cream

      // Node styling
      nodeBorder: '#F1540E',             // --accent-primary
      clusterBkg: '#faf2e7',             // --accent-cream-light
      clusterBorder: '#D44400',          // --orange-600 / --accent-hover

      // Font
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      fontSize: '16px'
    },
    flowchart: {
      nodeSpacing: 50,
      rankSpacing: 50,
      padding: 15,
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis'
    }
  });

  // Add copy buttons to Mermaid diagrams after rendering
  document.addEventListener('DOMContentLoaded', function() {
    const mermaidDivs = document.querySelectorAll('.mermaid');

    mermaidDivs.forEach(function(mermaidDiv) {
      // Get the original Mermaid source code
      const mermaidSource = mermaidDiv.textContent;

      // Create container wrapper
      const container = document.createElement('div');
      container.className = 'mermaid-container';

      // Create copy button
      const copyBtn = document.createElement('button');
      copyBtn.className = 'mermaid-copy-btn';
      copyBtn.textContent = 'Copy Mermaid Code';
      copyBtn.setAttribute('title', 'Copy diagram code for Draw.io, Mermaid Live, etc.');

      copyBtn.addEventListener('click', function() {
        navigator.clipboard.writeText(mermaidSource).then(function() {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');

          setTimeout(function() {
            copyBtn.textContent = 'Copy Mermaid Code';
            copyBtn.classList.remove('copied');
          }, 2000);
        });
      });

      // Wrap the mermaid div in container and add button
      mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
      container.appendChild(mermaidDiv);
      container.appendChild(copyBtn);
    });
  });
</script>
    <script src="../../js/main.js"></script>

            
<nav class="chapter-navigation" aria-label="Chapter navigation">
    <div class="next-chapter-content">
        <span class="next-chapter-label">Next Chapter</span>
        <span class="next-chapter-arrow" aria-hidden="true">→</span>
        <a href="05-api-functions-exhaustive.html" class="next-chapter-link" rel="next">Tutorial 5: API Functions (Comprehensive)</a>
    </div>
</nav>
</div>
        </div>
    </div>

    <!-- Footer -->
    {% include footer.html %}

    <!-- Back to Top Button -->
    <button id="backToTopBtn" title="Go to top">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
            <path d="M0 0h24v24H0V0z" fill="none"/>
            <path fill="currentColor" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
        </svg>
    </button>  </body>
